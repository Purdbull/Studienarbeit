%----------------------ANFORDERUNGSANALYSE-------------------


\chapter{Anforderungsanalyse (MT)}
\label{cha:anforderungsanalyse}

In diesem Kapitel wird mit \autoref{sec:ausgangslage} zunächst das bisherige System beschrieben. Mit den anschließenden Abschnitten \ref{sec:anforderungFunktionUndAufbau} bis \ref{sec:anforderungBestellstystem} werden die Anforderungen an das neue, digitale Transportsystem definiert. 

\section{Ausgangslage (MT)}
\label{sec:ausgangslage}
Die Gartenhochbahn stellt ein Transportsystem für Essen und Getränke dar. Hauptbestandteil des Systems ist eine Gondel, die sich mit Laufrädern auf einer Schiene fortbewegt. In \autoref{pic:oldhochbahn} ist die Gondel im initialen Zustand dargestellt. An dem Aufbau ist mit Ketten das Tablet befestigt, auf dem Speisen und Getränke abgestellt werden können.  

%@Moritz: Bitte noch Bild mit besserer Auflösung reinmachen.
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=8cm]{oldHochbahn.png}
		\caption{Initialzustand der Gondel}
		\label{pic:oldhochbahn}
	\end{center}
\end{figure}
\newpage

Der Antrieb der Gondel erfolgt mit einem Gleichstrommotor, der mit \acrfull{pwm} angesteuert wird. Die Kraftübertragung auf das treibende Laufrad erfolgt reibschlüssig. Für die Bereitstellung der Energie ist eine Batterie in der Gondel installiert. Diese wird in der Parkstellung am Ende der Schiene aufgeladen. Als Abschaltung des Motors an den hinteren Endlagen sind Tastsensoren verbaut. Ein \acrshort{reed}-Kontakt in der Gondel erkennt außerdem Magnete entlang der Strecke. Nach Erfassen eines Kontaktes an einer Endlage wird die Geschwindigkeit langsam reduziert. Für die Signalverarbeitung und Steuerung des Motors ist ein Arduino Nano im Einsatz. \\

Mit drei Tastern können verschiedene Stationen auf dem Weg angefahren werden. Damit ist ein einzelner Fahrzyklus bereits automatisiert. Ziel dieses Projektes ist es, den gesamten Bestellprozess mit Liefervorgang zu automatisieren. \\

Der bisherige Gondelaufbau entspricht in vielen Punkten nicht den Anforderungen. Dazu zählt vor allem der hohe Verschleiß des reibschlüssigen Antriebs. Da der initiale Aufbau in grundlegenden Punkten verändert werden müsste, wird im Rahmen des Projektes die Gondel neu aufgebaut. In den folgenden Abschnitten werden Anforderungen an die neue Gondel gestellt. 

\section{Funktion und Aufbau (MT)}
\label{sec:anforderungFunktionUndAufbau}
Der Aufbau soll dafür ausgelegt sein, Getränke und Speisen bis zu einem Gewicht von $\approx$5Kg zu transportieren. Um die Bestellung unversehrt liefern zu können, darf ein bestimmter Neigungswinkel nicht überschritten werden. Zu diesem Zweck muss das Kippmoment der Gondel abgefangen werden. Auf den Schienen muss sich die Gondel selbst bei engen Radien zuverlässig fortbewegen können. Damit die Entladespannung der Batterie nicht unterschritten wird, muss diese überwacht werden. Wird eine bestimmte Spannungsschwelle unterschritten, soll ein Zurückfahren in die Ladestation erzwungen werden. Da der größte Teil der Hochbahn überdacht ist, muss keine Rücksicht auf Witterungsbedingungen genommen werden. Die Konzeptionierung des Aufbaus erfolgt in \autoref{sec:konzeptGrundaufbau}.
\newpage


\section{Antrieb (MT)}
\label{sec:anforderungAntrieb}
Insgesamt soll der Antrieb eine hohe Zuverlässigkeit aufweisen und verschleißarm sein. 
Die Kraftübertragung soll mit einer passenden Übersetzung erfolgen. Durch den elektrischen Motor soll eine Regelung der Geschwindigkeit und Drehrichtung möglich sein. Wünschenswert wäre außerdem eine Rückmeldung der Umdrehungen. Beim Beschleunigen und Bremsen darf nichts von den Speisen und Getränken verschüttet werden. Dazu muss der Geschwindigkeitsgradient ausreichend klein sein. Das Konzept zum Antrieb wird in \autoref{sec:konzeptAktorik} beschrieben. 


\section{Sensorik (MT)}
\label{sec:anforderungSensorik}
Sensorik soll zu folgenden Zwecken eingesetzt werden: 

\begin{itemize}
	\item [a)] Positionserkennung 
	\item [b)] Kollisionsvermeidung  
	
\end{itemize}

Mit der Positionserkennung soll die Lage der Hochbahn auf der Transportstrecke erfasst werden können. Die Information soll der Steuerung zur Verfügung gestellt werden. Aufgrund der Information soll der Lieferungsvorgang nachvollzogen werden können und die Geschwindigkeitsregelung der Hochbahn eingestellt werden. Mit der Kollisionsvermeidung sollen Hindernisse im Fahrweg der Gondel rechtzeitig erkannt werden. Innerhalb eines definierten Warnbereiches soll die Geschwindigkeit stark gedrosselt werden. Wird durch das Hindernis außerdem ein Schutzfeld verletzt, muss die Bahn komplett zum Stillstand kommen. Die Konzeptionierung zur Sensorik wird in \autoref{sec:konzeptSensorik} beschrieben.

\section{Benutzeroberfläche (MT)}
Nutzern soll ermöglicht werden, die Bahn per Handy oder Tablet an eine gewünschte Position fahren zu lassen. Dabei soll die Oberfläche möglichst selbsterklärend sein, sodass neue Nutzer schnell erkennen, wie die Bahn anzusteuern ist. Ebenfalls sollen aktuelle Informationen der Bahn, wie beispielsweise die Position, angezeigt werden.

\section{Bestellsystem (INF)}
\label{sec:anforderungBestellstystem}

Das Bestellsystem soll es Nutzern ermöglichen, die Hochbahn mit einem Bestellauftrag zur Küche zu schicken. 
Dort soll ein Tablet die aktuelle Bestellung anzeigen. Ist alles für den Transport vorbereitet, kann ein Nutzer aus der Küche den Auftrag 
bestätigen und die Bahn fährt zur gewünschten Position zurück. \\
Zudem soll die Möglichkeit bestehen, den Bestand zu erfassen. Das System soll selbstorganisierend sein, sodass sich auch der erfasste Vorrat in der Küche durch Bestellungen aktualisiert. Dadurch soll verhindert werden, dass mehr als vorrätig ist bestellt werden kann.
Ebenfalls sollen Nutzer, die etwas bestellt haben, den aktuellen Lieferzustand einsehen können. D. h. es soll angezeigt werden, wo sich die Bahn befindet und welche Bestellung gerade bearbeitet wird.

%---------------------VORGEHENSWEISE-----------------

\chapter{Vorgehensweise}
\label{cha:vorgehensweise}
In diesem Kapitel wird die Vorgehensweise zur Bewerkstelligung des Projektzieles beschrieben. Um das Ziel zu erreichen, stand zunächst die Projektorganisation im Vordergrund. Diese wird in \autoref{sec:projektorganisation} erläutert. 

\section{Projektorganisation (MT)}
\label{sec:projektorganisation}
Die Projektorganisation erfolgte anhand der folgenden Stufen: 

\begin{enumerate}
	\item Projektstrukturplan %Akronym erstellen PSD!
	\item Projektablaufplan 
	\item Roadmap
	
\end{enumerate}

In einem ersten Schritt wurden mithilfe eines Projektstrukturplans die Teilbereiche definiert. Dadurch stellten sich die Wirkzusammenhänge der Bereiche heraus. Nachfolgend wurden die zugehörigen Aufgaben erstellt. Durch die Übersicht in einer Roadmap wurden die Aufgaben in einen zeitlichen Zusammenhang gebracht. 
In einem letzten Schritt folgte die Definition der Aufgaben in einem Kanban-Board. 


\newpage
\subsection{Projektstrukturplan (MT)}
In \autoref{pic:structuremech} ist der  Projektstrukturplan mit den mechatronischen Komponenten dargestellt. 

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=17cm]{projektstrukturplan.pdf}
		\caption{Projektstrukturplan mechatronischer Komponenten}
		\label{pic:structuremech}
	\end{center}
\end{figure}

Das Projekt ist untergliedert in drei Teilaufgaben. Diese werden in der nächsten Ebene in Arbeitspakete untergliedert. 
Da die Bereiche aufeinander aufbauend sind, können Zusammenhänge analysiert werden. In dem Schaubild sind die Bereiche von links nach rechts in zeitlicher Abfolge aufgetragen. Dementsprechend soll in einem ersten Schritt die Aktorik konzeptioniert werden. Dazu zählt die elektrische und mechanische Komponente des Antriebs. Mit den elektrischen Leistungsdaten der Aktorik wird im nächsten Schritt das Energiekonzept ausgearbeitet. Auf diesen Bereich baut final die Konzeptionierungsphase der Sensorik auf. \\ 

\newpage
\subsection{Projektablaufplan (MT)}
\label{sec:projektablaufplan}
Aus dem Projektstrukturplan geht der Projektablaufplan hervor. Darin werden die zuvor definierten Arbeitspakete aus den Teilaufgaben terminiert. Ein Ausschnitt aus dem Projektablaufplan der mechatronischen Komponenten ist in \autoref{pic:roadmap} dargestellt. 
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=17cm]{roadmap.png}
		\caption{Projektablaufplan mechatronischer Komponenten}
		\label{pic:roadmap}
	\end{center}
\end{figure}

\subsection{Planung für die informationstechnische Projektumsetzung (INF)}
Das Projekt ist in zwei Semester gegliedert. Im ersten Abschnitt sollen alle Softwarekomponenten konzeptioniert werden. Der Fokus liegt dabei auf der Konzeptionierung des verteilten Systems auf der Hochbahn, da dies den sicherheitskritischsten Faktor darstellt. Ebenfalls ist die Platine, welche das System vereint, zu Planen, zu Designen und zu Fertigen. Im Anschluss daran sollen im zweiten Abschnitt diese Konzepte umgesetzt werden. Die Platine bildet dabei das System, auf dem die einzelne Programme, insbesondere die Kommunikation zwischen den Controllern, zu Testen ist. Ein Webserver ist ebenfalls zu Implementieren.
Sind alle Komponenten fertiggestellt, soll das System vor Inbetriebnahme simuliert getestet werden.

\subsection{Arbeitsmangement (MT)}
\label{sec:arbeitsmanagement}
Für das Arbeitsmanagement wird die Kanban-Methode verwendet. Dabei werden die Teilaufgaben dem Bearbeitungsstatus zugeordnet. Im Rahmen des Projektes wurden die Stati \textit{Backlog}, \textit{Todo,  In Progress, Testing} und \textit{Done}  unterschieden. 
Die Aufgaben wurden mit den Berbeitungszeiträume aus dem Projektablaufplan definiert und dem entsprechenden Bearbeiter zugewiesen. 	
Für die Kanban-Methode kam das Tool \textit{Trello} zum Einsatz. 


%----------------------KONZEPT-------------------------

\chapter{Konzeptionierung der mechatronischen Komponenten (MT)}
\label{cha:konzeptionierung}
Mit \autoref{cha:anforderungsanalyse} wurden Anforderungen an das Projekt gestellt. Zum Erreichen dieser Anforderungen findet in diesem Kapitel die Konzeptionierung statt. Dazu wird mit \autoref{sec:konzeptGrundaufbau} zunächst der generelle Aufbau betrachtet. Anschließend folgen mit den Abschnitten \ref{sec:konzeptAktorik} bis \ref{sec:konzeptSensorik} die Konzepte zu den mechatronischen Komponenten \textit{Aktorik}, \textit{Energieversorgung} und \textit{Sensorik}. Als Übergang zu den informationstechnischen Konzepten werden mit \autoref{sec:konzeptSchnittstellen} die \textit{Schnittstellen} ausgearbeitet. \newpage

\section{Grundaufbau}
\label{sec:konzeptGrundaufbau}
Beim Aufbau der neuen Gondel wird das grundlegende Prinzip des bisherigen Aufbaus übernommen. Dazu zählt, dass die Gondel mit zwei Elementen in die Schiene eingehängt wird. Die beiden Baugruppen werden nachfolgend als \textit{Triebwagen} und \textit{Stützwagen} bezeichnet. Beide Elemente besitzen ein Paar Laufrollen für die Fortbewegung auf der Schiene. Im Triebwagen sind zusätzlich Motor und Getriebe verbaut. An den beiden Baugruppen werden nach unten Verbindungselemente für die Befestigung des Tabletts sowie für die Elektronik angebracht. Zur besseren Veranschaulichung ist in  \autoref{pic:grundaufbau} die Konstruktion der beiden Wägen dargestellt. Die Beschreibung der Konstruktion folgt im Teil der \textit{Umsetzung} in \autoref{cha:umsetzung}.


\begin{figure}[h]
	\centering
	\includegraphics[width=8cm]{grundaufbau.png} 
	\caption{Konstruktionsansicht von Trieb- und Stützwagen}
	\label{pic:grundaufbau}
\end{figure}
Eine dringende Anforderung an den Aufbau ist, dass die Gondel stets lotrecht hängt. Aus diesem Grund wir nun das Kippmoment betrachtet. 
\newpage

\textbf{Ausgleich des Kippmoments}\\
 Durch die einseitige Belastung des Motors ergibt sich vor allem beim Triebwagen ein Kippmoment. Eine mögliche Lösung wäre, das Kippmoment durch eine Laufrolle auf der Seitenfläche der Schiene abzufangen. Aufgrund der Befestigung der Schiene ist dies jedoch nicht möglich. Aus diesem Grund soll das Kippmoment durch ein entgegengesetztes Drehmoment mit einem Gewicht erzeugt werden. In \autoref{pic:kippmoment} ist der Zusammenhang veranschaulicht. 

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{kippmoment.pdf} 
	\caption{Betrachtung des Kippmoments am Triebwagen}
	\label{pic:kippmoment}
\end{figure}
Der Aufbau dreht sich um den Punkt $D$. Für die lotrechte Ausrichtung der Gondel muss gelten, dass 

\begin{align}
	\sum M_D = 0
\end{align}
\newpage 

 Der Motor hat mit einer Masse von $300g$ eine Gewichtskraft von $F_{G,M} \approx 2,94N$. Der Hebelarm ist $l_1=70mm$. Dieses positive Drehmoment soll mit einem negativen Moment durch das Gewicht mit der Kraft $F_{G,G}$ und Hebelarm $l_2$ ausgeglichen werden. Bei gegebenem Hebelarm $l_2$ ergibt sich dabei für die erforderliche Masse des Gewichtes:

\begin{align}
	m_G = m_M \cdot \frac{l_1}{l_2}
\end{align}
 
In der Praxis gilt es zu untersuchen, inwiefern ein zusätzliches Gewicht beim Stützwagen notwendig ist. Generell ist anzunehmen, dass durch die Last des Tablets die Gondel zusätzlich stabilisiert wird.  

\section{Aktorik}
\label{sec:konzeptAktorik}
In diesem Abschnitt wird die Konzeptionierung des Antriebs der Gartenhochbahn beschrieben. In \autoref{sec:konzeptMotor} wird zunächst die Auswahl und Auslegung des Motors erläutert. Das Drehmoment des Motors soll anschließend auf ein Laufrad übertragen werden. Die Beschreibung des dafür zuständigen Getriebes folgt mit \autoref{sec:getriebekonzept}

\subsection{Motor}
\label{sec:konzeptMotor}
Für den Antrieb der Gartenhochbahn wurde zwischen einem DC-Motor und einem Schrittmotor ausgewählt. Bei einem DC-Motor wird ein \acrshort{pwm}-Signal angelegt. Dieses wird von einem Treiber generiert. Bei einem Schrittmotor werden bei der Steuerung von einem Treiber positive Taktflanken des Controllers ausgewertet. Wie in \autoref{sec:schrittmotor} beschrieben, werden je nach Betriebsmodus pro Taktflanke die Spulen des Motors entsprechend bestromt. Durch den Zusammenhang zwischen Taktflanken und  Inkrementalschritten des Motors können Rückschlüsse auf die zurückgelegte Strecke gemacht werden.  

Da die Information der Wegstrecke für die Positionsbestimmung genutzt werden kann, soll für die Gartenhochbahn ein Schrittmotor verwendet werden. Dafür kommt der Hybrid-Schrittmotor Nema 17-04 von Joy-IT zum Einsatz. Als Schrittmotortreiber wird der DRV8834 von Texas Instruments verwendet. 


Für die Ansteuerung des Schrittmotortreibers soll ein Arduino Nano das \acrshort{pwm}-Signal generieren. Auf dem Controller soll eine Library ausgeführt werden, die als Input die Zielgeschwindigkeit sowie Richtung entgegennimmt. Durch die Library wird das \acrshort{pwm}-Signal für den Treiber ausgegeben. Dabei soll eine bestimmte Beschleunigungs- bzw. Bremsrate variabel einstellbar sein. Des weiteren soll die Library für den Motortreiber weitere, erforderlichen Signale wie bspw. Richtung und Schrittmodus ausgeben. Die detaillierte Beschreibung zur Umsetzung der Motorsteueurung erfolgt mit \autoref{sec:motorsteuerung} 



\subsection{Getriebe}
\label{sec:getriebekonzept}
Das Getriebe sorgt für die Kraftübertragung des Motordrehmoments auf die Schiene. Zusätzlich ist die Geschwindigkeit der Hochbahn vom Übersetzungsverhältnis des Getriebes abhängig. Nachfolgend wird die Auswahl der Getriebeart und anschließend die Auslegung beschrieben. \\

\textbf{Getriebeart}\\
Für die Auswahl der Getriebe steht ein Zahnradgetriebe und ein Zugmittelgetriebe im Raum. Das Zahnradgetriebe besitzt eine formschlüssige Kraftübertragung der beiden Räder. Damit diese mit dem geeigneten Kopfspiel zustande kommt, müssen die beiden Wellen in einem exakten Abstand zueinander stehen. Das bedarf einem hohen Grad an Präzision bei der Fertigung. Bei einem Zugmittelgetriebe kann bspw. eine Spannrolle dafür sorgen, dass das Zugmittel ausreichend gespannt ist. Dadurch muss der Abstand der beiden Räder zueinander ein niedrigeres Maß an Genauigkeit besitzen. 
Für das Projekt wird ein Zugmittelgetriebe verwendet. Um dabei Schlupf zu vermeiden, wird ein T-Profil bei Riemen und Rad verwendet. 
\\

\textbf{Konstruktion und Fertigung}\\
Der Antrieb besteht aus den folgenden Komponenten: \textit{getriebenes}- und \textit{treibendes Riemenrad, Laufrad} und \textit{Zahnriemen}. Zunächst wird das Konzept für das getriebene Riemenrad und das Laufrad beschrieben. Anschließend erfolgt die Beschreibung des gesamten Antriebs anhand der Konstruktion.  
Das Laufrad kommt für den Abtrieb auf der Schiene zum Einsatz. Eine Herausforderung stellt dabei die Kraftübertragung vom Laufrad auf das getriebene Riemenrade dar. Dazu wurden zwei Konzept entwickelt. Die Gegenüberstellung ist in \autoref{pic:abtriebkonzepte} dargestellt.
\newpage

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=17cm]{abtriebkonzepte.pdf}
		\caption{Konzepte für die Kraftübertragung vom Riemenrad auf das Laufrad}
		\label{pic:abtriebkonzepte}
	\end{center}
\end{figure}


Bei Konzept a) wird für Lauf- und Riemenrad jeweils ein Normteil verwendet. Die Kraftübertragung zwischen den beiden Rädern erfolgt über eine Welle. Diese ist gelagert, während die beiden Räder stehend auf der Welle montiert sind. Die Normteile der beiden Räder sind meist für hohe Krafteinwirkungen in industriellem Einsatz ausgelegt. Dadurch ergibt sich bei Verwendung der Räder ein hohes Gewicht. Die Bauteile sind jedoch mit hohen Kosten verbunden.

Bei Konzept b) sind Laufrad und Riemenrad eine Baugruppe. Das kombinierte Bauteil wird additiv gefertigt und ist stehend auf der Welle gelagert. Die Welle selbst ist ebenfalls stehend ausgeführt. Durch die additive Fertigung ist eine CAD-Konstruktion zwingend notwendig. Dadurch ergibt sich in diesem Punkt ein höherer Aufwand als bei der Verwendung von Normteilen. Die Konstruktion bietet jedoch den Vorteil, dass das Laufrad an das Profil der Schiene angepasst werden kann. 

Für das Projekt wird Konzept b) verfolgt. Die additive Fertigung des Bauteils sollte für die Krafteinwirkung ausreichend sein und die Kosten können somit geringer gehalten werden. 

\newpage

\section{Energieversorgung}
\label{sec:konzeptEnergieversorgung}
Die Batterie, bestehend aus zwei Li-Ion-Zellen, dient als Energieversorgung für Aktorik, Sensorik und Steuerung. Um für die Komponenten passende Ströme und Spannungen bereitstellen zu können, sind diverse Leistungskonvertierungen nötig. In \autoref{pic:leistungskonvertierung} sind die zu diesem Zweck verwendeten Komponenten dargestellt und in \autoref{tbl:leistungskonvertierung} aufgelistet. 

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=12cm]{leistungskonvertierung.pdf}
		\caption{Schema zur Leistungskonvertierung der elektrischen Komponenten}
		\label{pic:leistungskonvertierung}
	\end{center}
\end{figure}


\begin{table}[h]
	\begin{center}
		\begin{tabular}[h]{l|l|l}
			\textbf{Name} & \textbf{Bezeichnung} & \textbf{Bauteill}\\
			\hline
			G1 & Li-Ion Batterien in Reihe & 2x Panasonic NCR18650B\\
			\hline
			T1 & DC-DC-Wandler & Polulu S7V7F5\\
			\hline
			T2 & Step-Up Converter & LAOMAO XL6009 \\
			\hline
			T3 & Schrittmotor Treiber & Polulu DRV8834 \\
			\hline
			K1 & Steueurungen & Arduino Nano, ESP32 \\
		\end{tabular}
	\end{center}
	\caption{Bezeichnungen verwendeter Komponenten}
	\label{tbl:leistungskonvertierung}
\end{table}
\newpage

Die Li-Ion Batterie darf eine minimale Zellspannung $U_{min} =2,75V$ (\acrshort{cutoffvoltage}) nicht unterschreiten. Im Schema nicht dargestellt ist der Hochbahncontroller ESP32, der die Entladespannung kontinuierlich überprüft und vor Erreichen der \acrshort{cutoffvoltage} die Fahrt zur Ladestation einleitet. Der Converter T2 stellt die Leistung für den Schrittmotor bereit. Am Schrittmotortreiber $T3$ lässt sich die für den Motor geforderte Spannung und maximale Stromstärke einstellen. Dafür findet im Treiber ebenfalls eine Leistungskonvertierung von $V_{in}=6,6V$ auf $V_{Motor}=3,3V$ statt. Der Step-Up Converter $T1$ passt die Eingangsspannung an die erforderliche Spannung der Controller an. Die Ausgangsspannung des Converters liegt bei $5 \pm 0,15 V$ \\

Die Li-Ion Batterien sollen in der Parkposition der Hochbahn aufgeladen werden. Eine Batterie kann bei einer Ladespannung von $4,2V$ aufgeladen werden. Für die Steuerung des Ladevorgangs kommt der Ladecontroller $MCP73831/2$ von Microchip zum Einsatz. Der Controller lässt einen Ladestrom von $500mA$ zu. 


\newpage

\section{Sensorik}
\label{sec:konzeptSensorik}
Zur $Kollisionsvermeidung$ und $Positionserfassung$ kommen Sensoren zum Einsatz. Diese werden in den nächsten beiden Abschnitten beschrieben.

\subsection{Kollisionsvermeidung}
\label{sec:konzeptKollisionsvermeidung}
Für die Kollisionsvermeidung soll mithilfe von Ultraschallsensoren kontinuierlich die Distanz $d$ zum nächsten Objekt gemessen werden. Als Sensoren werden zwei HC-SR04 auf dem Tablett angebracht. Der Messbereich beträgt $0,02m - 5m$ (\cite{hcrs04}). Der Sensorbereich soll in ein Warn- und Schutzfeld eingeteilt werden. Das Warnfeld wird verletzt, wenn bei mindestens einem der beiden Sensoren $d<1,5m$ erfüllt ist. Eine Schutzfeldverletzung erfolgt bei $d<0,7m$. 

In \autoref{pic:kollisionsvermeidung} sind die beiden Ultraschallsensoren mit Warn- und Schutzfeld dargestellt. 

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=16cm]{kollisionsvermeidung.pdf}
		\caption{Schematische Anordnung der Ultraschallsensoren HC-SR04 auf dem Tablett zur Kollisionsvermeidung mit den Warn- und Schutzfeldbereichen}
		\label{pic:kollisionsvermeidung}
	\end{center}
\end{figure}
\newpage

Die Breite $b$ des kleinsten zu erfassende Objektes beim Öffnungswinkel $\alpha = 30^{\circ}$ beträgt:

\begin{align}
	b= tan(\alpha) \cdot d \cdot 2
\end{align}

 Dabei beträgt das kleinste erfassbare Objekt am Ende des Schutzfelds $b_S \approx 0,4m$ und am Ende des Warnfelds $b_W \approx 0,8m$. \\
 
Der Ultraschallsensor HC-SCR04 Ultraschallsensor verfügt für die Messung der Schalllaufzeit über die beiden Pins \textit{TRIG} und \textit{ECHO}. Die Messung wird durch eine fallende Flanke von 10µs am Triggereingang gestartet. Anschließend werden über den  Piezokristall des Sensors acht aufeinanderfolgende 40Khz Schallwellen ausgesandt. Nach 200µs setzt der Sensor \textit{ECHO} so lange auf high, bis der Ultraschallimpuls empfangen wurde. Wurde keine Schallreflektion empfangen, verbleibt  \textit{Echo} für max. 38 ms auf HIGH. Eine erneute Messung kann frühestens nach 20ms gestartet werden. (vgl. \cite{hcrs04})

Mit einem Arduino Nano werden die Messungen an beiden Sensoren zyklisch durchgeführt. Die Berechnung der Distanz erfolgt anhand der in \autoref{sec:ultraschall} beschriebenen Formel. Tritt eine Schutz- oder Warnfeldverletzung auf, gibt der Arduino ein Signal auf einen entsprechenden Interrupt-Pin am ESP32 als  Hochbahn-Controller. Die verwendeten Interrupt-Pins sind nachfolgend dargestellt. \\


\begin{center}
	\begin{tabular}[h]{l|l|l}
		Sensor & Verletzung  & ESP32 Interrupt-Pin \\
		\hline
		1 & Warnfeld & GPIO1\\
		\hline
		1 & Schutzfeld & GPIO2\\
		\hline
		2 & Warnfeld & GPIO3\\
		\hline
		2 & Schutzfeld & GPIO4\\	
	\end{tabular}
\end{center}
\newpage

\subsection{Positionserfassung}
\label{konzeptPositionserfassung}
Die Position der Hochbahn entlang der Strecke soll kontinuierlich erfasst werden. Dafür kommen zwei Lokalisierungsmethoden zum Einsatz: 

 \begin{itemize}
 	\item [a)] Absolute Positionserfassung durch einen \acrshort{reed}-Kontakt
 	\item[b)] \acrshort{lagekopplung} auf Basis des Feedbacks der Motorsteuerung  
 \end{itemize}

Für die absolute Positionserfassung sollen entlang der Strecke Dauermagneten in einem Abstand von 1,5m angebracht werden. Die Magneten schließen den Kontakt des  \acrshort{reed}-Schalters auf der Hochbahn. Zusammen mit der Information zur Fahrtrichtung wird ein Zählwert auf dem Hochbahncontroller ESP32 inkrementiert bzw. dekrementiert. Auf Basis des Feedbacks der Motorsteuerung wird aus der aktuellen Geschwindigkeit die diskrete Position zwischen den Magneten berechnet. Diese Art der \acrshort{lagekopplung} ist prinzipbedingt fehlerbehaftet. Daher wird bei absoluten Markern der Inkrementalwert zurückgesetzt. 
\newpage

\section{Schnittstellen}
\label{sec:konzeptSchnittstellen}
Als Übergang von der Konzeptionierung mechatronischer Komponenten zu den informationstechnischen Konzepten soll in diesem Abschnitt die Schnittstelle aller verwendeten Komponenten vorgestellt werden. Dazu ist in \autoref{pic:schnittstellen} eine Übersicht dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm]{schnittstellen.pdf}
	\caption{Schnittstellenübersicht der verwendeteter Komponenten}
	\label{pic:schnittstellen}
\end{figure}

In dem Schema sind die Komponenten hierarchisch dargestellt. Die Pfeile dazwischen stellen die Schnittstellen dar. Der Webserver kommuniziert mit den Endgeräten der Kunden oder dem Tablet in der Küche über \acrshort{http}. Mit POST-Requests werden Steuerbefehle oder Bestellungen zur weiteren Verarbeitung an den Server geschickt.
\acrshort{mqtt} dient zur Kommunikation zwischen dem Server und der Hochbahn. Für die Übermittlung der \acrshort{mqtt}-Befehle  befindet sich ein \acrshort{mqtt}-Broker auf der Kommunikationsebene. Die Hochbahn erhält Information über die Station, die angefahren werden soll. Während der Fahrt gibt die Bahn Rückmeldung über die aktuelle Position. Außerdem sollen Meldungen des Systems zur Kollisionsvermeidung und der Entladespannung der Batterie übertragen werden. Auf der Hochbahn führt ein ESP32 als Controller die Kommunikation durch. Die Steuerung des Motors und die Kollisionsvermeidung sind auf zwei Arduino Nanos ausgelagert. Der ESP32 ist den beiden Controllern übergeordnet. Für die Kommunikation zwischen der Motorsteuerung und dem ESP32 wird \acrshort{uart} zur seriellen Kommunikation verwendet. Der Hochbahncontroller versendet darüber Befehle zur Motorfrequenz und empfängt dafür von der Motorsteuerung die aktuelle Geschwindigkeit. \autoref{sec:motorsteuerung} beschreibt die Umsetzung der Motorsteuerung. Wie in Abschnitt \ref{sec:konzeptKollisionsvermeidung} beschrieben, überprüft die Sicherheitssteuerung kontinuierlich die Distanzwerte der Ultraschallsensoren. Ist eine Kollision zu erwarten, setzt die Steuerung einen entsprechenden Interrupt am Hochbahn-Controller. Der \acrshort{reed}-Kontakt für die Positionserfassung ist über $I/O$-Pins direkt mit dem Hochbahncontroller verbunden. 

\chapter{Entwicklung der Platine (INF)}
\label{sec:ecardConcept}
In \autoref{sec:konzeptSchnittstellen} wurde bereits angedeutet, dass auf der Hochbahn mehrere elektronische Komponenten zusammenarbeiten müssen (Arduino, ESP32, etc.). Daher werden diese Komponenten sowie die benötigte Peripherie, auf einer Platine zu einem verteilten System vereint. 
Die Entwicklung dieser Platine wird in Folgendem erläutert.

\section{Anforderungen an die Platine}
Die Platine muss folgende Anforderungen erfüllen: 
\begin{center}
	\begin{itemize}
		\item Kommunikation zwischen Hochbahn-Controller und Motorsteuerung,
		\item Spannungsversorgung der einzelnen Mikrokontroller,
		\item Spannungsüberwachung beider Batteriezellen,
		\item Interruptleitungen von Reed-Kontakt und Sicherheitssteuerung,
		\item Selbstabschaltung des Systems
		\item und Anschluss von Motortreiber und Ultraschallsensoren.
	\end{itemize}
\end{center}
All diese Anforderungen sollen möglichst gering im Leistungsverbrauch umgesetzt werden. \newpage 

\section{Kommunikation über UART}
\label{sec:uartecard}
Generell erfolgt die Kommunikation der beiden Mikrocontroller über \acrshort{uart}. Daraus folgt, dass der \acrfull{rx}-Pin des Hochbahn-Controllers (ESP32) mit dem \acrfull{tx}-Pin der Motorsteuerung (Arduino), sowie der \acrshort{rx} des Arduinos mit dem \acrshort{tx} des ESP32 verbunden sein muss. 
Daraus resultiert folgendes Problem: \\
Ein Arduino wird bei einer Betriebsspannung von $5V$ versorgt während der ESP32 eine Spannung von $3,3V$ benötigt. Dadurch erhielte der ESP32 beim Empfangen von Nachrichten einen zu hohen HIGH-Pegel wobei der Arduino Nachrichten mit zu niedriger Spannung bekäme.

\subsection{Level-Shifter}
Um die Signale des ESP32 auf die richtige Spannung zu erhöhen, wird ein sogenannter Level-Shifter verwendet. Dieser übermittelt Signale mit einer Spannung von $ 5V $ an den Arduino, während der ESP32 nur $ 3,3V $ ausgibt.
Der zugehörige Schaltplan ist in \autoref{pic:levelshift} dargestellt.
\vspace{1cm}

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=9cm]{levelShifter.PNG}
		\caption{\label{pic:levelshift}Schaltplan des Level-Shifters}
	\end{center}
\end{figure}

Angenommen, der ESP32 gibt an \textit{data in} ein \texttt{Low}-Signal, würde der MOSFET aufgrund der $ 3,3V $ am Gate des Mosfets aktiviert. Somit wird \textit{data out} durch das Mosfet ebenfalls auf $ 0V $ gezogen. 
Liegt \textit{data in} jedoch auf $ 3,3V, $ gibt es keinen Spannungsunterschied zwischen Gate und Source des Mosfets. Dadurch wird es deaktiviert, sodass \textit{data out} auf 5V gezogen wird. 
Somit erzeugt eine positive Flanke von 3,3V des ESP32 eine Flanke von 5V am Arduino.

\subsection{Spannungsteiler}
Um 5V Pulse zu 3,3V zu konvertieren, ist nicht zwingend eine Mosfet oder Transistorschaltung nötig. Hierzu genügt ein Spannungsteiler. Dieser ist in \autoref{pic:spannungsteiler} gezeigt.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=9cm]{spannungsteiler.PNG}
		\caption{\label{pic:spannungsteiler} Spannungsteiler zur Kommunikation von Arduino zu ESP32}
	\end{center}
\end{figure}

Aus dem Verhältnis von $1 \div 1,6$ der beiden Widerstandsgrößen wird eine Ausgansspannung von ca. 3,08V bei einem 5V Pegel erzeugt. Diese wird in jedem Fall als logisches \texttt{HIGH} interpretiert.

\subsection{Spannungsversorgung}
Auf der Platine gibt es drei unterschiedliche Betriebsspannungen: 
\begin{center}
	\begin{itemize}
		\item 3,3V für den ESP32,
		\item 5V für beide Arduini und Stepper-Driver
		\item und 10V für den Schrittmotor.
	\end{itemize}
\end{center}
All diese Spannungen kommen aus der Stromquelle, welche aus den zwei Zellen der Litium-Ionen Akkus besteht. Die Spannung liegt, je nach Ladezustand, zwischen ca. 7,4V und 8,2V. Da die Komponenten jedoch zu jedem Zeitpunkt die gleiche Spannung benötigen, werden Spannungsregler benötigt. 
Einer davon ist ein DC/DC-Wandler, welcher die Zellspannung auf konsistente 5V für beide Arduini regelt. Da der ESP32 selbst einen Spannungsregler von 5V auf 3,3V besitzt, kann dieser ebenfalls an die Arduino-Versorgungsleitung angeschlossen werden. Ein Step-Up-Wandler erzeugt aus besagten 5V eine Spannung von 10V für Motortreiber und Schrittmotor. 

\section{Spannungsmessungen an den Batteriezellen}
\label{sec:mess}
Die Stromversorgung der Hochbahn stellen zwei in Reihe geschaltete Lithium Ionen Akkus dar. Diese Reihenschaltung ist in \autoref{pic:messfalsch} gezeigt. Während bei einfachen Batterien die Gesamtspannung gemessen werden kann, müssen hier die beiden Zellen einzeln betrachtet werden.
Um die einzelnen Zellen zu messen, soll die Spannung jeweils am + Pol abgegriffen werden. Somit muss die Messeinrichtung von der Gesamtspannung jene der ersten Zelle abziehen, um die Spannung der zweiten Zelle zu erhalten. Dieser Vorgang ist erforderlich, da kein Spannungsunterschied zwischen + und - der oberen Zelle gemessen werden kann. Grund dafür ist, dass \gls{gnd} des Arduinos gleich mit \gls{gnd} der unteren Zelle ist.
Verbände man, wie in \autoref{pic:messfalsch} gezeigt, zwei analoge Pins direkt mit den + Polen, wäre eine Spannungsmessung in der Theorie möglich.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=7.5cm]{wrongMeasure.PNG}
		\caption{\label{pic:messfalsch} Einfache (nicht implementierte) Spannungsmessung der Zellen}
	\end{center}
\end{figure}

In der Praxis ergeben sich dabei jedoch zwei Probleme:

\begin{center}
	\begin{itemize}
		\item [1.] Wenn die Spannungsversorgung der Platine abgeschaltet ist, würde ein Arduino sich über die analogen Pins selbst versorgen, wodurch ein unnötiger Stromverbrauch entstände. Dadurch würden sich die beiden Zellen im schlimmsten Fall tiefenentladen.
		\item [2.] Ein Arduino kann nur Spannungen zwischen 0V und 5V messen, wodurch eine Reihenschaltung der beiden 3,7V Zellen auch im entladenen Zustand am analogen Input 5V, also 100\%, erzeugen. 
	\end{itemize}
\end{center}

Die in Folgendem erklärte Schaltung soll diese Probleme umgehen.
\subsection{Mosfetschaltung zur aktivierbaren Spannungsmessung}
\label{sec:mosfetmess}
Diese Schaltung soll es ermöglichen, die Spannungsmessung per Signal aktivieren zu können. Das Signal wird dabei vom messenden Arduino mit einem 5V-Pegel erzeugt. Ist die Schaltung aktiviert, sollen - ähnlich wie in \autoref{pic:messfalsch} - beide Spannungen abgegriffen werden.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=11cm]{messRichtig.PNG}
		\caption{\label{pic:messrichtig} Mosfetschaltung zur aktivierbaren Spannungsmessung}
	\end{center}
\end{figure}

Die Mosfetschaltung zur Messung der ersten unten liegenden Zelle ist in \autoref{pic:messrichtig} gezeigt.
Zu sehen sind ein p- und ein n-Kanal Mosfet. Das unten geschaltete n-Kanal-Mosfet verbindet bei einer positiven Spannung auf \textit{digital in} das Gate vom p-Kanal-Mosfet mit \gls{gnd}. Dadurch wird das p-Kanal-Mosfet geschaltet, wodurch bei \textit{voltage out} eine Spannungsmessung möglich wird. Die Spannung ist jene, die am 1M$\Omega$ Widerstand abfällt. Der Widerstand bildet einen Spannungsteiler mit 10K$\Omega$. Da 1M$\Omega$ im Verhältnis jedoch viel größer ist, fällt fast die gesamte Spannung an diesem Widerstand ab, sodass diese an \textit{voltage out} gemessen werden kann.

\subsection{Spannungteiler für die zweite Zelle}
In \autoref{sec:mess} wurde beriets erwähnt, dass die gemessene Spannung an der zweiten Zelle zu hoch für den Arduino ist. Deshalb muss die Schaltung aus \autoref{pic:messrichtig} folgendermaßen erweitert werden:

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=13cm]{messMitTeiler.PNG}
		\caption{\label{pic:messrichtigmitteiler} Mosfetschaltung zur aktivierbaren Spannungsmessung mit Spannungsteiler}
	\end{center}
\end{figure}

In \autoref{pic:messrichtigmitteiler} ist zu sehen, dass die Schaltung um einen Spannungsteiler erweitert wurde. Da beide Widerstände den gleichen Wert haben, kann zwischen ihnen die Hälfte der Spannung gemessen werden. 
Um in der Software die richtige Spannung der Zelle zu erhalten, ist der gemessene Wert zu verdoppeln. Zieht man nun die Spannung der ersten Zelle ab, ist das Ergebnis die Spannung der zweiten Zelle.

\chapter{Konzeption des verteilten Systems auf der Hochbahn (INF)}
\label{sec:software}
Die Software der Anlage lässt sich in zwei Bereiche gliedern: \textit{Webserver im Heimnetzwerk} und \textit{Client auf der Hochbahn}. Der Webserver soll ein Interface für Benutzer der Anlage bereitstellen, mit dem die Hochbahn gesteuert werden kann. 
Der Client bekommt daraufhin Befehle vom Webserver und führt diese, sofern möglich, aus. 

\section{Konzept für die Aufgabenverteilung auf der Hochbahn}
\label{sec:hochbahnAlsClient}
Wie schon in \autoref{sec:konzeptSchnittstellen} angeführt, sollte die Software ursprünglich in drei Hauptkomponenten getrennt weden:
\begin{itemize}
	\item ESP32 als Hochbahn-Controller zur Befehlserkennung und Steuerung der Hochbahn,
	\item Arduino als Motorsteuerung
	\item  und Arduino als Sicherheitssteuerung zur Ultraschallüberwachung .
\end{itemize}
\autoref{sec:konzeptSchnittstellen} stellte das erste Konzept zur Aufteilung der Aufgabenbereiche dar. Nach Evaluierung der hierbei aufkommenden Fehlerquellen sind einige Änderungen getroffen worden.
Ursprünglich sollte der ESP32 die Hauptsteuerung übernehmen. Er sollte Befehle wie \texttt{beschleunigen} oder \texttt{abbremsen auf Geschwindigkeit x} zur Motorsteuerung geben und dabei die aktuelle Position sowie die daraus resultierenden nächsten Schritte selbst berechnen. Die Erfahrung zeigt jedoch, dass ein ESP32 durch erhöhte Netzlast oder Verbindungsabbrüche leicht zum Absturz gebracht werden kann. Würde das bspw. passieren während die Bahn auf die Endstation zurollt, bekäme die Motorsteuerung nicht rechtzeitig den Befehl zum Abbremsen und es käme zu einem Unfall.
Deshalbwurde die Hauptsteuerung an den Arduino, welcher ursprünglich nur den Motor steuern sollte, übergeben. Daraus resultiert das nachfolgend vorgestellte Konzept zur Aufgabenverteilung auf der Hochbahn.

\subsection{ESP32 als Schnittstelle zum Server}
\label{sec:aufgabeESP}
Der ESP32 soll nach wie vor Befehle des Webservers entgegen nehmen. Er ist ebenfalls mit dem Reedkontakt, welcher über Magneten an der Schiene die Position aktualisiert, verbunden. Dies ermöglicht, unabhängeíg von der Motorsteuerung, Positionsmeldungen an den Webserver zu schicken. Zudem gibt der ESP32 Befehle an die Motorsteuerung, welche sich allerdings auf die anzufahrende Position beschränken. Die Fahrt selbst wird vom Arduino wie folgt gesteuert.

\subsection{Arduino-Nano als Motorsteuerung}
\label{sec:aufgabeArduinoNanoMotor}
Die Motorsteuerung erhält vom ESP32 Anfahrpositionen. Über den Interrupt des Reedkontakts zählt der Arduino die aktuelle Fahrposition mit. Daraufhin soll ein individuelles Fahrprogramm des Schemas \textit{Von x nach y} berechnet und ausgeführt werden. Außerdem sind zwei analoge Pins angeschlossen, über die der Ladezustand der Batteriezellen gemessen werden kann. Der zweite - an die Motorsteuerung angeschlossene Interrupt - dient der Kollisionserkennung. Dieser wird von einem weiteren Arduino, welcher die Ultraschallsensoren steuert, übermittelt. 

\subsection{Arduino Nano zur Ultraschallüberwachung} 
\label{sec:aufgabeArduinoNanoUltraschall}
Dieser Arduino hat ausschließlich die Aufgabe, beide Ultraschallsensoren (jeweils einer auf jeder Seite des Tabletts) zu überwachen und mit einem Pin Auskunft darüber zu geben, welches Warn- oder Schutzfeld verletzt wurde. Da nur ein Pin zur Verfügung steht, bestimmt die Länge des \texttt{High}-Signals die Art der Kollisionserkennung.
\newpage
\section{Protokoll der Seriellen Schnittstelle}
Die Datenübertragung erfolgt, wie in \autoref{sec:konzeptSchnittstellen} besechrieben, über \acrshort{uart}. In den Grundlagen (\autoref{sec:uart}) ist zu aufgeführt, wie \acrshort{uart} die Daten byteweise übertragen werden. Die Bytes werden in einen Puffer geschrieben und können auf Anwendungsebene Byteweise ausgelesen werden. Daher ist es logisch, das Protokoll so zu konzeptionieren, dass möglichst wenige (bzw. pro Befehl nur ein Byte) verwendet wird. 

\subsection{Anfragen- und Befehlsarten}
Anfrage- oder Befehlsnachrichten können auf zwei Wegen erfolgen: Vom ESP32(Hochbahn-Controller) zum Arduino (Motorsteuerung) oder umgekehrt. Es soll insgesamt fünf Kategorien an Datenübertragungen geben:

\begin{itemize}
	\item [1.] Positionsabfrage (ESP32 $\rightarrow$ Arduino),
	\item [2.] Positionsmeldung (Arduino $\rightarrow$ ESP32),
	\item [3.] Akkustandsmeldung (Arduino $\rightarrow$ ESP32),
	\item [4.] Fahrbefehl (ESP32 $\rightarrow$ Arduino)
	\item [5.] und Bestätigung von Fahrbefehlen (Arduino $\rightarrow$ ESP32).
\end{itemize}

Da es pro Übertragungsweg nur maximal drei verschiedene Arten von Nachrichten gibt, ergeben sich zwei Bits für den Header des Protokolls. Dadurch kann festgestellt werden, um welche Art von Nachricht es sich handelt.
Soll eine Nachricht nur ein Byte groß sein, bleiben somit sechs Bits für den Body der Nachricht. 
\autoref{tab:header} zeigt die Header der verschiedenen Nachrichtenarten:

\begin{table}[h]
	\begin{center}
		\begin{tabular}{m{2cm} | m{2cm} | m{5cm} | m{5cm}}
			Bit \texttt{0} & Bit \texttt{1} & Bedeutung & Nachrichtenweg\\
			\hline 
			\texttt{0} & \texttt{0} & Positionsabfrage  & ESP32 $\rightarrow$ Arduino\\
			\hline 
			\texttt{0} & \texttt{0} & Akkumeldung & Arduino $\rightarrow$ ESP32\\
			\hline 
			\texttt{0} & \texttt{1} & Fahrbefehl & ESP32 $\rightarrow$ Arduino\\
			\hline 
			\texttt{1} & \texttt{0} & Positionsmeldung & Arduino $\rightarrow$ ESP32\\
			\hline 
			\texttt{1} & \texttt{1} & Befehlsakzeptierung & Arduino $\rightarrow$ ESP32\\
		\end{tabular}
	\end{center}
	\caption{\label{tab:header}Header des Nachrichtenprotokolls}
\end{table}

\subsection{Nachrichtencontext (Body)}
Der Body einer übertragenen Nachricht wird je nach Header anders interpretiert. Beispielsweise können übertragene Werte den aktuellen Ladezustand des Akkus oder die Position der Hochbahn bedeuten. 
In folgender Tabelle sind die verschiedenen Arten des Contexts mit entsprechendem Header aufgelistet:

\begin{table}[h]
	\begin{center}
		\begin{tabular}{r | l | l}
			Body & Header & Bedeutung \\
			\hline
			\texttt{000000} - \texttt{000111} & \texttt{10} & Positionsmeldungen von 0 - 7 \\
			\hline
			\texttt{000000} - \texttt{000111} & \texttt{01} & Fahrbefehle von 0 - 7 \\
			\hline
			\texttt{000000} & \texttt{00} & Positionsabfrage \\
			\hline
			\texttt{000000} - \texttt{001111} & \texttt{00} & Akkumeldung von 0-100\% in ~ 6\% Schritten \\
			\hline
			\texttt{000001} und \texttt{000010} & \texttt{11} & Befehlsakzeptanz \texttt{01} = ja; \texttt{10} = nein\\  
		\end{tabular}
	\end{center}
	\caption{\label{tab:body}Body des Nachrichtenprotokolls}
\end{table}

\subsection{Tail}
In \autoref{tab:body} ist zu erkennen, dass nie die letzten beiden Bits verwendet werden. Diese dienen dazu, den Transportweg der Nachricht zu erkennen. Dadurch ist es möglich, zu erkennen, ob es sich beim Header \texttt{00} um eine Positionsabfrage oder eine Akkumeldung handelt.
Ist das Tail mit \texttt{01} gekennzeichnet, handelt es sich um eine Nachricht von ESP32 zu Arduino. \texttt{10} steht für die umgekehrte Richtung.
In folgendem sind zwei Beispielnachrichten genannt, welche der Definition des Protokolls entsprechen:

\begin{center}
	\begin{itemize}
		\item \texttt{01000000}; Positionsabfrage von ESP32 zum Arduino
		\item \texttt{10001110}; Positionsmeldung mit dem Context: Position 3  
	\end{itemize}
\end{center}
\newpage


\chapter{Konzeptionierung der einzelnen Softwarekomponenten der Hochbahn (INF)}\label{sec:softwareKomp}
\section{Zustandsautomaten}
Auf der Hochbahn befinden sich zwei Softwarekomponenten, die untereinander Nachrichten austauschen. Dies dient der Synchronisierung und Ausführung von Fahrbefehlen. Der Ablauf, welcher im erfolgreichen Fahren mündet, ergibt sich wie folgt:
\begin{center}
	\begin{itemize}
		\item ESP32 $\Leftarrow$ Server: \textit{Fahr zu Position y!}
		\item ESP32 $\Rightarrow$ Arduino: \textit{Wo genau stehen wir?}
		\item ESP32 $\Leftarrow$ Arduino: \textit{Position x!}
		\item ESP32 $\Rightarrow$ Arduino: \textit{Fahr zu Position y!}
		\item ESP32 $\Leftarrow$ Arduino: \textit{OK!}
	\end{itemize}
\end{center}
Der hier aufgelistete Ablauf ist fehlerlos dargestellt. Die Positionsabfrage dient dazu, auch auf dem ESP32 immer die richtige Position zu speichern. Er besitzt hierbei einen falschen Wert, falls er durch Netzkommunikation einen Positionswechsel nicht mitbekommt. \\
 Zur Kommunikation und genereller Steuerung der Software auf den Microcontrollern werden Zustandsautomaten verwendet. Der Gedanke dabei ist, dass ein Zustand nur eine gewissen Eingabe erwartet. So ist es möglich, dynamisch auf falsche Geschehnisse zu reagieren.

\subsection{Zustandsautomat des ESP32}
\label{sec:stateESP}
Dieser Zustandsautomat hat - wie schon in \autoref{sec:aufgabeESP} erwähnt - die Aufgabe der Vermittlung zwischen Server und Motorsteuerung.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=16cm]{stateMaschineESP.pdf}
		\caption{\label{pic:statemaschineESP}Zustandsautomat des ESP32 grafisch dargestellt}
	\end{center}
\end{figure}

In \autoref{pic:statemaschineESP} sind alle Zustände, sowie Zustandsübergänge dargestellt. Das Programm startet im Zustand \texttt{IDLE}. Ein Zustandswechsel kann durch eine Nachricht von Server oder Arduino erfolgen. Eine Akkumeldung des Arduinos führt zu einer Akkumeldung zum Server. Der Automat bleibt dabei im Zustand \texttt{IDLE}.
Erhält der ESP32 einen Fahrbefehl vom Server, wechselt er zu Zustand \texttt{START}. Dieser beginnt eine Folge von Nachrichten und Handlungen mit dem Ziel, \textit{die aktuelle Position der Hochbahn zu synchronisieren und den Fahrbefehl auszuführen}. \\
Dazu wird zunächst eine Positionsanfrage an den Arduino geschickt und in den Zustand \texttt{POSITION} gewechselt. Erhält der ESP32 daraufhin die Position, kann er die eigens gespeicherte aktualisieren und einen Fahrbefehl an den Arduino senden. Ist dies geschehen, befindet sich der ESP32 im Zustand \texttt{END} und wartet auf eine Akzeptierung seitens des Arduinos. Akzeptiert dieser, wechselt der ESP32 wieder zu Zustand IDLE und der Kreislauf beginnt von vorne. Sollte der Arduino die Anfrage ablehnen oder sonst irgendetwas schiefgehen, wird die Kette unterbrochen und in den Zustand \texttt{ERROR} gewechselt. Dieser kann mittels des vorherigem Zustand eine Fehlermeldung an den Server schicken, welche dem Nutzer angezeigt wird. Daraufhin kann ein neuer Fahrbefehl oder Akkuzustand empfangen werden. 

\subsection{Zustandsautomat der Motorsteuerung}
\label{sec:stateARD}
Ähnlich wie in \autoref{sec:stateESP} wird auch die Software der Motorsteuerung (Arduino) als Zustandsautomat realisiert. 
Der Automat ist in \autoref{pic:statemaschineARD} gezeigt.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=16cm]{stateMaschineARD.pdf}
		\caption{\label{pic:statemaschineARD}Zustandsautomat der Hauptsteuerung als Grafik}
	\end{center}
\end{figure}

Zu sehen ist dabei wieder eine Kreisstruktur, bei der die einzelnen Zustände über \texttt{ERROR} unterbrechen und wieder zu \texttt{IDLE} rücksetzen können. Im Zustand \texttt{IDLE} wird die Batteriespannungen überprüft um rechtzeitig zur Ladestation zu fahren, falls diese die Entladeschlussspannung beinahe erreicht haben. In diesem Fall schaltet sich die Bahn ab, sobald sie an der Ladestation angedockt ist. Wird eine Positionsanfrage empfangen, übermittelt Zustand \texttt{POSITION} die aktuelle Position und der Automat wechselt zu Zustand \texttt{WAIT}. Dieser wartet auf den Fahrbefehl und akzeptiert diesen nach Überprüfung. Zustand \texttt{DRIVE} führt den Fahrbefehl aus und der Automat wechselt zurück zu \texttt{IDLE}

\section{Konzeptionierung der Fahrfunktion}
\label{sec:konFahr}
Die Hauptfunktion dieser Methode folgt der folgenden Struktur: \textit{Die Bahn fährt von A nach B.} B ist in diesem Fall die anzufahrende Position, welche vom Server übermittelt wurde. Aus acht Abschnitten auf der Strecke und der Möglichkeit jeden Abschnitt von jedem Abschnitt aus anzufahren ergeben sich 56 individuelle Fahrprogramme. Die Ausprogramierung aller Fahrprogramme würde einen erheblichen Aufwand bedeuten. Aus diesem Grund wurden Regeln ausformuliert, nach denen der Controller die Fahrpgromme selbst zusammenstellt. Diese werden nachfolgend beschrieben. 

\subsection{Regeln zur Bestimmung des Fahrprogramms}
\label{sec:rules}
Auf der Strecke gibt es zwei unterschiedlich Arten anfahrbaren Positionen:
\begin{center}
	\begin{itemize}
		\item [1.] Ein Abschnitt auf der Strecke
		\item [2.] Eine der beiden Endpositionen.
	\end{itemize}
\end{center}
Der Unterschied liegt darin, dass die Bahn bei einer der beiden Endpositionen exakt am Magneten anhalten muss, während beim Anfahren von Aschnitten der Stopp zwischen zwei Magneten erfolgen soll. Die anzupeilende Geschwindigkeit ist in Prozent der Maximalgeschwindigkeit angegeben.
\newpage 
\subsubsection{Regel 1: Maximalgeschwindigkeit einzelner Abschnitte}
\autoref{pic:positionen} zeigt die Strecke (schwarz) der Hochbahn.
Wie zu erkennen ist, gibt es sowohl sehr kurvige als auch längere gerade Streckenteile. Die Strecke wird daher in acht Abschnitte unterteilt, die jeweils angefahren werden können. Abschnitt null und sieben sind die Endpunkte der Hochbahnstrecke.  In \autoref{pic:positionen} sind diese Acht Abschnitte - jeweils durch Magnete von einander getrennt - zu sehen.
\begin{figure}[h]
	\begin{center}
		\includegraphics[width = \textwidth]{Positionen.pdf}
		\caption{\label{pic:positionen} Hochbahn-Strecke als Grafik}
	\end{center}
\end{figure}

Das Tablett, welches an der Hochbahn befestigt ist, kann auf horizontaler Ebene schwingen. Ein solcher Schwingvorgang kann unter anderem durch schnelle Kurvenfahrten entstehen und sollte vermieden werden. Aus diesem Grund wird für eine erste Annahme als Höchstgeschwindigkeit bei Kurvenfahrten 30\%  angenommen. Nach dieser ersten Regel wird für jeden Abschnitt eine Maximalgeschwindigkeit festgelegt.

\subsubsection{Regel 2: Geschwindigkeit des vorletzten Abschnitts}
Die Geschwindigkeit muss bereits vor Eintreten in den letzten Abschnitt so gering sein, dass innerhalb des Abschnitts angehalten, bzw. der letzte Magnet angefahren werden kann. Es wird angenommen dass bei einer Geschwindigkeit von 50\% immer möglich sei, innerhalb eines Abschnitts auf 0\% abzubremsen. Daraus folgt, dass die Maximalgeschwindigkeit im vorletzten Abschnitt einer Fahrstrecke 50\% nicht überschreiten darf. 

\subsubsection{Regel 3: Geschwindigkeit des ersten Abschnitts}
Der erste Asbchnitt ist jener, mit dem die Bahn die Fahrstrecke beginnt. Er wird also nur teilweise durchfahren, bevor die Bahn in den zweiten Abschnitt mit anderer Maximalgeschwindigkeit fährt. Daraus folgt, dass die Höchstgeschwindigkeit im ersten Abschnitt nicht höher sein soll als die des zweiten Abschnitts, da sonst die Bahn nach Beschleunigen direkt wieder abbremsen müsste. So lässt sich weitere Schwingung in Fahrtrichtung vermeiden.

\subsubsection{Regel 4: Geschwindigkeit des letzten Abschnitts}
Im letzten Abschnitt muss die Geschwindigkeit $= 0$ sein, sodass die Bahn anhält. Handelt es sich beim letzten Abschnitt um eine Endposition, wird die Geschwindigkeit auf ein Minimum gesetzt, um erst beim Ankommen am letzten Magneten anzuhalten. Das Anhalten selbst wird durch eine Fahrfunktion der Motorlibrary erreicht. 

\subsection{Priorisierung der Regeln}
Je nach Länge der Fahrstrecke variiert die Anzahl der überfahrenen Abschnitte zwischen zwei und acht. Einzelne Regeln können andere überschreiben, was im schmlimmsten Fall zu Regelverstoß, bzw falschen Geschwindigkeiten führt. Die niedrigste Priorität hat die zuerst angewendete Regel, da alle gesetzten Geschwindigkeitswerte von anderen Regeln überschrieben werden können.
\\
Betrachtet wird nun beispielhaft die Fahrt von Abschnitt fünf zu Abschnitt vier. Regel eins wird zuerst angewendet, da sie generelle und nicht fahrspezifische Geschwindigkeiten bestimmt. In diesem Fall ergäben sich die Abschnitte wie folgt:

\begin{center}
	\begin{itemize}
		\item 100 | 80
	\end{itemize}
\end{center}

Regel 4 sollte die höchste Priorität besitzen, da durch Verletzung die Hochbahn zu spät anhält. Da ein Abbremsen innerhalb des letzten Abschnitts wichtiger ist als das Verhidnern einer zu hohen Beschleunigung im ersten Abschnitt, wird Regel drei niedriger priorisiert als Regel vier. Somit ergeben sich die Abschnitte nach dem zweiten Regeldurchlauf folgendermaßen:

\begin{center}
	\begin{itemize}
		\item 80 | 80
	\end{itemize}
\end{center}

Nach dem dritten Durchlauf wird somit die Geschwindigkeit des vorletzten Abschitts auf 50 verringert, wonach im letzten Durchlauf die Zielabschnittsgeschwindigkeit auf 0 gesetzt wird. 

Ein weiteres Beispiel mit einer Fahrt von Abschnitt zwei zu Abschnitt sechs zeigt die Geschwindigkeitsverteilung bei einer längeren Fahrt:

\begin{center}
	\begin{itemize}
		\item Anwendung von Regel 1: 30 | 40 | 80 | 100 | 90 
		\item Anwendung von Regel 3: 30 | 40 | 80 | 100 | 90 
		\item Anwendung von Regel 2: 30 | 40 | 80 |  50 | 90 
		\item Anwendung von Regel 4: 30 | 40 | 80 |  50 |  0 
	\end{itemize}
\end{center}

Die Priorisierung $Regel1 <  Regel3 <  Regel2  < Regel4$ kann  sowohl ein zu schnelles Ankommen der Bahn im letzten Abschnitt, als auch unnötige Beschleunigungen vermeiden.

\chapter{Server (INF)}
\label{sec:server}
Die ursprüngliche Konzeptionierung dieses Projekts plante ein Bestellsystem. Dieses wurde aufgrund der stark gestiegenen Komplexität des verteilten Systems auf der Hochbahn in den Ausblick dieser Arbeit verschoben. Da ein Server nun nur Steuerbefehle weiterleitet, wäre es einfach, diesen vom ESP32 der Hochbahn selbst hosten zu lassen. Da das System jedoch auch nach Ende dieser Arbeit weiterentwickelt werden soll, wird hierbei trotzdem eine Grundlage geschaffen, um später das Bestellsystem leichter hinzufügen zu können. Daher ist ein Server zu entwickeln, welcher die komplexe Implementierung eines Bestellsystems ermöglicht. 
\section{ASP.NET-Core}
Nach Evaluierung verschiedener Frameworks für die Serverprogrammierung, fiel die Entscheidung auf APS.NET-Core. Grund dafür war einerseits eine persönliche Vorliebe für die Programmiersprache C\#, im Gegensatz zu beispielsweise Python mit Django als Framework. Ebenfalls bietet ASP.NET-Core die Möglichkeit, einen \acrshort{mqtt}-Broker als zusätzliche Komponente des Systems zu hosten. Somit wird im Betrieb auf dem Raspberry PI nur noch der Server getartet, ohne einen Broker installieren und starten zu müssen. \\
Das Framework baut auf \acrfull{mvc} auf. Dieses gliedert eine Serverapplikation in Models, View und Controller. Models sind eine Art Datenmodell, welches zur individuellen Nutzung, oder für Datenbanken verwendbar ist. Views sind Seiten, also Benutzeroberflächen, die dem Nutzer angezeigt werden. Controller bilden die Schnittstelle zwischen Browser und Server. Models werden aktuell noch vernachlässigt, da aufgrund der geringen Funktionlität keinerlei Objekte beispielsweise in eine Datenbank geschrieben werden müssen. Kommt das Bestellsystem hinzu, sind Models für Bestellungen oder Nutzer zu Implementieren. Der Server dient jedoch vorerst nur als Vermittler zwischen Benutzer und Hochbahn ohne individuelle Anforderungen zu erfüllen, welche Models benötigen würden. Auf Views und Controller kann trotz geringer Fnktionalität nicht verzichtet werden. 

\section{Views}
\subsection{Index}
Index ist jene Seite, die beim ersten Aufruf der Website gezeigt wird. Sie soll dem Nutzer anzeigen, wo sich die Bahn aktuell befindet. Zudem soll die Möglichkeit bestehen, einen Fahrbefehl an die Bahn zu schicken. Der Konzeptionierung der Fahrfunktion ist eine Grafik zu entnehmen, bei der die einzelnen Abschnitte der Bahn erkennbar sind (\autoref{pic:streckengrafik}). Ist diese Grafik auch auf der Seite zu sehen, kann ein Nutzer bei einer Eingabe die gewünschte Position auswählen und als Fahrbefehl verschicken. Als Eingabefunktion wurde aufgrund symbolischer Ähnlichkeit ein Slider verwendet. Auf Darlegung des Design-Codes (hierbei bestehend aus css und Bootstrap) wird in dieser Arbeit verzichtet, da der Fokus auf Technik und Funktionalität liegt. 

\begin{lstlisting}[language=html, style=dhpaperdefault]
<div class="text-center">
    <h1>Steuerung</h1>
    <h4>Fahre zu Position <div id="output"></div></h4>
    <input id="input" type="range" min="0" value="0" max="7" step="1">
    <div class="row">
        <div onclick="driveTo()"><button>Fahrbefehl senden</button></div>
    </div>
    <h4>Aktuelle Position: <div id="data-position"></div></h4>

	<img src="images/Streckengrafik.PNG"/>
</div>
\end{lstlisting}
\captionof{lstlisting}{\label{code:index} Index.html des Servers}
\vspace{0.5cm}

In \autoref{code:index} ist der HTML-Code der Hauptseite zu sehen. Zu erkennen ist ein \texttt{Input} des Types \texttt{Range} (Slider), dessen Wert über seine \texttt{ID} erhalten werden kann. Die Funktion \texttt{driveTo()}, welche beim Klicken auf den \texttt{Button} gestartet wird, entnimmt diesen Wert und sendet ihn via \acrshort{mqtt} an die Bahn (Mehr dazu unter \autoref{sec:serverMqtt}). Die Hochbahn schickt, bei Änderung der Position, diese an den Server. Auf dem Server soll also immer die aktuelle Position der Bahn gespeichert sein. Änderungen des Inhalts auf der Seite des Servers hat generell keine Auswirkung auf jene die beispielsweise auf dem Handy angezeigt wird, da das Handy sich beim ersten Aufruf die Seite holt und diese nicht aktualisiert. Daher ist der Einbau einer Funktionalität nötig, die Clientseitig periodisch Daten wie die aktuelle Position aktualisiert. Die Position soll im \texttt{div} der ID \texttt{data-position} angezeigt werden. Um aktuelle Daten vom Server zu erhalten, wird Clientseitig ein GET-Request durchgeführt. Dieses Request erfragt definierte Daten vom Server und kann von jedem Gerät, welches die Seite aufruft, durchgeführt werden. Beim ersten Aufruf der Website wird beispielsweise ein GET-Request auf die Seite Index durchgeführt. \\
HTML bietet die Möglichkeit einer \texttt{onload} - Methode. Diese wird ausgeführt, sobald die Seite aufgerufen wird. Im Falle des Hochbahnservers initialisiert die \texttt{onload} - Methode die periodische Ausführung verschiedener GET-Requests. 
\vspace{0.5cm}
\begin{lstlisting}[language=html, style=dhpaperdefault]
	function init() {
		var intervalId = setInterval(function () {
			getWarningMsg();
			getErrorMsg();
			getBatteryVal();
			getPosition();
		}, 500);
	}
\end{lstlisting}
\captionof{lstlisting}{\label{code:init} Initialisierung der periodischen GET-Requests}
\vspace{0.5cm}
In \autoref{code:init} ist die Initialisierungsfunktion zu erkennen. Sie setzt ein intervall von 500 Millisekunden. Das bedeutet, dass die Methode alle 500 Millisekunden ausgeführt wird. So führt jedes Gerät welches die Hauptseite lädt alle 500 Millisekunden verschiedene Get-Requests auf verschiedene Informationen der Hochbahn durch, welche dem jeweiligen Methodennamen zu entnehmen sind. 

\subsection{Info}
Auf der Infoseite sind aktuelle Informationen über die Hochbahn zu sehen. Hierbei gibt es drei Kategorien:

\begin{center}
	\begin{itemize}
		\item Warnungen,
		\item Fehlermeldungen
		\item und der Akkustand.
	\end{itemize}
\end{center}
\newpage
GET-Requests auf diese Informationen werden mit jener für die Position der Hochbahn initialisiert. Ein solches Request erfolgt folgendermaßen:

\begin{lstlisting}[language=html, style=dhpaperdefault]
	function getErrorMsg() {
		$.ajax({
			type: "Get",
			url: "/Home/Error",
			success: function (data) {
				$('#data-error').text(data);
			},
			error: function () {
				alert("Server down");
			}
		});
    }
\end{lstlisting}
\captionof{lstlisting}{\label{code:get}GET-Request auf die Fehlermeldungen}
\vspace{0.5cm}
\autoref{code:get} zeigt ein GET-Request auf die URL \texttt{Home/Error}. Die Antwort des Servers überträgt im Parameter \texttt{data} die aktuelle Fehlermeldung. Diese wird im Anschluss an das Textfeld mit der ID \texttt{data-error} übergeben. 
\subsection{Benutzeroberfläche}
Ein Nutzer, der mit einem Smartphone die Seite im Heimnetzwerk aufruft, also im Browser die IP-Adresse des Servers eingibt, kann auf die beiden Seiten zugreifen, welche in \autoref{pic:ui} gezeigt sind.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=\textwidth]{UI.pdf}
		\caption{\label{pic:ui}Benutzeroberfläche zur Hochbahnsteuerung}
	\end{center}
\end{figure}

Links ist die Seite \textit{Index}, rechts die Seite \textit{Info} zu sehen. Die Streckengrafik zeigt dem Nutzer, wo sich die einzelnen Abschnitte befinden. So kann er auf dem \texttt{Slider} genau bestimmen, wohin die Bahn fahren soll. Unter Info werden aktuelle Fehlermeldungen, Warnungen sowie der Batteriezustand gezeigt. Sie zeigen jeweils die neueste Meldung der Hochbahn. Sofern die Bahn eine Fahrt erfolgreich ausgeführt hat, werden die Werte für Warnung und Error zurückgesetzt, damit ein aufgetretener Fehler nicht auf der Seite angezeigt wird, sofern er an bedeutung verloren hat. 
\newpage
\section{Controller}
\label{sec:controller}
Da nur zwei Seiten existieren, wird nur ein Controller benötigt. Handelte es sich um eine Website mit wesentlich mehr Einzelseiten und Funktionalitäten wie Bestellsystem, wäre es sinnvoll, auch Controller in beispielsweise Home- und Bestellcontroller zu Gliedern. \\

\subsection{Home-Controller}
Der einzige Controller des Servers hat die Aufgabe Anfragen an beide Seiten des Servers zu verwalten. Dies können GET oder auch POST-Requests sein, welche sowohl auf die ganze Seite, als auch einzelne Inhalte erfolgen können.
\newpage
\begin{lstlisting}[language=c, style=dhpaperdefault]
//get index-page
public IActionResult Index()
{
	return View();
}

//send position to train
[HttpPost]
[Route("Home/Position")]
public IActionResult driveTo(int position)
{
	string topic = "Train/driveToPosition";
	string message = position.ToString();
	_mqttService.sendMessage(topic, message);
	return Ok();
}

//get position from train
[HttpGet]
[Route("Home/Position")]
public IActionResult getPosition()
{
	return Content(_mqttService.getPosition());
}
\end{lstlisting}
\captionof{lstlisting}{\label{code:requests} Anfragen an den Server}
\vspace{0.5cm}

In \autoref{code:requests} sind die drei verschiedenen Anfragen gezeigt, welche an den Server gestellt werden können. Die erste ist ein GET-Request an die Hauptseite. Das \texttt{return}-Statement sucht in diesem Fall nach einer HTML-Datei Namens \texttt{Index}, welche an das fragende Gerät zurückgegeben wird. Die zweite Funktion zeigt ein POST-Request, bzw. die serverseitige Antwort auf ein POST-Request an die URL \texttt{Home/Position}. Diese entnimmt dem POST die Position und übermittelt diese mit \texttt{\_mqttService} an das Topic (\texttt{Train/driveToPosition}), sodass der ESP32 auf der Hochbahn die Position entwerten kann. Die dritte Anfage ist wieder ein GET, jedoch mit dem Ziel nur die Information \texttt{position} und keine ganze Seite zu erhalten. Zurückgegeben wird hier die Variable \texttt{Position}, welche im \texttt{\_mqttService} gespeichert ist. Wie diese Information von der Hochbahn erhalten wird, ist im Folgenden erklärt.
\section{MQTT}
\label{sec:serverMqtt}
Neben dem laufenden \acrshort{mqtt}-Broker wird zusätzlich ein \acrshort{mqtt}-Server benötigt, um Nachrichten zu empfangen und zu senden. Dieser wird im \texttt{Startup} als ein Service registriert. Dieser Service wird anschließend als Singleton umgesetzt, damit von überall im Code auf den gleichen Service zugegriffen wird:

\begin{lstlisting}[language=c, style=dhpaperdefault]
public void ConfigureServices(IServiceCollection services)
{
	services
	.AddHostedMqttServer(mqttServer => mqttServer.WithoutDefaultEndpoint())
	.AddMqttConnectionHandler()
	.AddConnections()
	.AddControllersWithViews();

	services.AddSingleton<IMqttService>(x => new Services.MqttService(_server));

	services.AddMqttConnectionHandler();
	services.AddMqttWebSocketServerAdapter();

}
\end{lstlisting}
\captionof{lstlisting}{\label{code:services} ConfigureServices des Servers}

\vspace{0.5cm}
Neben dem Singleton werden in \autoref{code:services} weitere Handler-Funktionen von \acrshort{mqtt} als Service registriert. Diese werden vom Broker benötigt. Der Parameter \texttt{\_server} ist eine Instanz eines Interfaces, welches selbst geschrieben werden muss. Dieses muss alle benötigten \acrshort{mqtt} - Methoden implementieren, wie beispielsweise \acrshort{mqtt} - Messages verschicken. Im Falle dieser Arbeit werden folgende Funktionen benötigt:

\begin{center}
	\begin{itemize}
		\item Nachricht senden,
		\item Fehler, Warnung, Position und Akkumeldungen erhalten.
	\end{itemize}
\end{center}

Um eine Nachricht zu verschicken werden zwei Übergabeparameter benötigt: Die zu verschickende NAchricht und das Topic, an jenes sie geschickt werden soll. 
\newpage
\begin{lstlisting}[language=c, style=dhpaperdefault]
public Task sendMessage(string topic, string payload)
{
	var msg = new MqttApplicationMessageBuilder()
				.WithPayload(payload)
				.WithTopic(topic);

	this._mqttServer.PublishAsync(msg.Build());
	return Task.CompletedTask;
}
\end{lstlisting}
\captionof{lstlisting}{\label{code:mqttSend} Sende-Methode des \acrshort{mqtt} - Services}

\vspace{0.5cm}
In \autoref{code:mqttSend} ist die Sende-Methode gezeigt. \texttt{MqttApplicationMessageBuilder} konvertiert die Nachricht mit Topic in ein \acrshort{mqtt}-Format, welches dann mit der Methode \texttt{PublishAsync} an den Broker übermittelt wird. Dieser verwaltet im Anschluss die Übertragung an die Hochbahn, da sie sich an dem gewünschte Topic angemeldet hat.\\
Das Empfangen von Nachrichten erfolgt über eine Callback-Methode, die bei jeder empfangenen Nachricht aufgerufen wird. Initialisiert wird diese im Konstruktor des \texttt{mqtt} - Services.

\begin{lstlisting}[language=c, style=dhpaperdefault]
_mqttServer.UseApplicationMessageReceivedHandler(async e =>
{
	string topic = e.ApplicationMessage.Topic;
	if (string.IsNullOrWhiteSpace(topic) == false)
	{
		string payload = GetString(e.ApplicationMessage.Payload);
		if(topic == "Train/Error")
		{
			this.ErrorMsg = payload;
		}
		
		//other topics
	}
}
});

\end{lstlisting}
\captionof{lstlisting}{\label{code:mqttReceive}Emfangsmethode des \acrshort{mqtt} - Services}
\vspace{0.5cm}

Die in \autoref{code:mqttReceive} gezeigte Methode überprüft, um welches Topic es sich handelt, bzw. an welches Topic die Nachricht geschickt wurde. Je nach Topic wird im Anschluss das Payload, bzw. der Nachrichtencontext, in der ihm zugewiesenen Variable gespeichert. Eine Fehlermeldung landet somit immer in der Variable \texttt{ErrorMsg}. Für den gleichen Zweck existieren noch die Variablen \texttt{WarningMsg, PositionMsg und BatteryMsg}. In \autoref{sec:controller} ist bereits gezeigt, wann diese Variablen ausgelesen werden. 

\chapter{Umsetzung der mechatronischen Komponenten (MT)} 
\label{cha:umsetzung}
Im ersten Teil der Studienarbeit stand die Konzeptionierung in \autoref{cha:konzeptionierung} im Vordergrund. Auf dieses Kapitel aufbauend soll der aktuelle Stand der Umsetzung beschrieben werden. Dieser beschränkt sich  auf die Motorsteuerung in \autoref{sec:motorsteuerung} sowie die Getriebekonstruktion in \autoref{sec:getriebekonstruktion}.
\newpage
 
\section{Motorsteuerung}
\label{sec:motorsteuerung}

Wie in \autoref{sec:konzeptAktorik} beschrieben, wird der Schrittmotor mithilfe des Treibers DRV8834 von Texas Instruments angesteuert. Die vom Treiber benötigten Signale werden dafür von einem Arduino Nano generiert. Zu diesem Zweck wurde die Library \texttt{HighTrainStepper} geschrieben. Von außen kann der Library  eine Geschwindigkeit sowie eine Beschleunigung vorgegeben werden. Die Library steuert dann die Motordrehzahl mit der definierten Beschleunigungsrate an. Dazu wird ein \acrshort{pwm}-Signal über Interrupts generiert. Zusätzlich sind mit der Funktion \texttt{stopMode} bereits vorkonfigurierte Anhalteszenarien implementiert. Mit \autoref{sec:driver} werden zunächst die vom Motortreiber benötigten Signale aufgeführt. Es folgt die Konfiguartation der Interrupts sowie die Implementierung der Interrupt Service Routine (\acrshort{isr}) mit \autoref{sec:interrupt} sowie \autoref{sec:isr}. Abschließend  werden die vorkonfigurierten Anhalteszenarien in \autoref{sec:stopMode} erläutert.


\subsection{Signale des Schrittmotortreibers}
\label{sec:driver}

In \autoref{tbl:pololuDriver} sind die Signale definiert. 

\begin{table}[h]
	\begin{center}
		\begin{tabular}[h]{l|l}
			\textbf{Signal} & \textbf{Definition} \\
			\hline
			clk & Takt zum Weiterschalten eines Schrittes, \acrshort{pwm}-Signal des Controllers\\
			\hline
			m0,m1 & Signalepegel für die Einstellung der Schrittmodi\\
			\hline
			en & Aktiveren des Motortreibers\\
			\hline
			dir & Einstellen der Fahrtrichtung\\
		\end{tabular}
	\end{center}
	\caption{Übersicht der benötigten Signale des Schrittmotortreibers DRV8834 von Texas Instruments}
	\label{tbl:pololuDriver}
\end{table}

Durch Aktivieren des Signals \textit{en} wird der Schrittmotor bestromt. Ohne das Signal besitzt der Motor ausschließlich das innere Rastmoment. Mit \textit{m0} und \textit{m1} wird der Schrittmodus eingestellt. Für das Projekt relevant sind Vollschritt, Halbschritt und Viertelschritt. Bei einer positiven Taktflanke an \textit{clk} bestromt der Treiber die nächste Spule, wodurch sich der Motor um eine Rastung weiter dreht. Während der Arduino dafür das  \acrshort{pwm}-Signal generiert, soll dieser weiterhin in der Lage sein, andere Prozesse auszuführen. Um dies zu gewährleisten, wurde die Generierung der  \acrshort{pwm} in einer \acrshort{isr} ausgelagert, welche kontinuierlich durch einen internen Timer des Arduinos aufgerufen wird. Nachfolgend wird die dafür vorgenommene Konfiguration des Interrupt-Registers beschrieben.\\

\subsection{Konfiguration des Interrupt-Registers}
\label{sec:interrupt}

In \autoref{code:interrupt} ist der Code zur Konfiguartion des Interrupt-Registers aufgeführt. Des Weiteren zeigt \autoref{pic:interrupt} eine Übersicht des Timer/ Counter Control \textit{TCCR1A} Registers sowie des Maskierungsregisters \textit{TIMSK1}.

\begin{lstlisting}[language=c, style=dhpaperdefault]
void Stepper::initInterrupts() {
	cli;	//Alle Interrput-Flags loeschen
	TCCR1A = 0;	//Control Register A zuruecksetzen
	TCCR1B = 0;	// Control Register B zuruecksetzen
	TCCR1B |= (1 << WGM12); // CTC Modus aktivieren
	TCCR1B |=  (1 << CS11;	// Aktiviere 8 Bit Prescaler
	TCNT1  = 0;	// Initialisierung des Zaehlwertregisteres auf Wert 0
	OCR1A = MAXVAL;	//Vergleichsregister auf Hoechstwert
	TIMSK1 |= (1 << OCIE1A); // Erlaube Timer compare interrupt TIMSK 
	sei(); //interrupts aktivieren 
}
\end{lstlisting}
\captionof{lstlisting}{\label{code:interrupt}Konfiguration des Timer/Counter Control Registers }

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=\textwidth]{interrupts.png}
		\caption{\label{pic:interrupt}Übersicht über das Timer Counter Compare Register 1 \textit{TCCR1A} sowie das Maskierungsregister \textit{TIMSK1} des ATmega328}
	\end{center}
\end{figure}

Die Timer des ATmega328-Chip können über das Timer/Counter Control Register \textit{(TCCR)} konfiguriert werden. Zu Beginn wird das gesamte Register zurückgesetzt. Im Byte \textit{TCCR1B} kann mit den Bits \textit{WGM12} und \textit{WGM13} ein sog. Waveform Generation Mode eingestellt werden. In diesem Fall wurde das Bit \textit{WGM12} gesetzt, wodurch der Modus "Clear Timer on Compare Match" \acrshort{ctc} aktiviert wird. 
Dabei wird der aktuelle Zählwert von Timer1 fortlaufend mit dem Register \textit{OCR1A} verglichen. Hat Timer1 den Registerwert erreicht, wird die \acrshort{isr}  \texttt{TIMER1\_COMPA\_vect} ausgeführt. Innerhalb der Service Routine wird die \acrshort{pwm} durch Umschalten eines Ausgangspins generiert. \newpage

Der Systemtakt $f_{clock}$ des ATmega328 beträgt $16 Mhz$. Durch die Einstellung eines Teilers ("Prescalers") kann der Takt, mit welchem Timer1 inkrementiert wird, eingestellt werden. Für die sich ergebende \acrshort{pwm}-Frequenz durch Vergleich mit dem Register \textit{OCR1A} gilt: 

\begin{align}
	f_{PWM} = \frac{1}{2} \cdot \frac{f_{clock}}{Prescaler \cdot (OCR1A+1)}
\end{align}

Das  \acrshort{pwm}-Signal ist in \autoref{pic:pwm} veranschaulicht. 

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=10cm]{pwm.pdf}
		\caption{Benutzeroberfläche zur Hochbahnsteuerung}
		\label{pic:pwm}
	\end{center}
\end{figure}

In der Interruptkonfiguration wurde mit dem Bit \textit{CS11} innerhalb des Registers \textit{TCCR1B} der Prescaler mit dem Nenner 8 aktiviert. Als Minimal- und Maximalwerte des Vergleichregisters \textit{OCR1A} wurden die Werte 5500 und 950 ausgewählt. Damit ergibt sich als minimale und maximale Frequenz des \acrshort{pwm}-Signals:

\begin{align}
	f_{PWM}(5500) \approx 182 Hz \\
	f_{PWM}(950) \approx 1050 Hz
\end{align}


Für die Geschwindigkeit der Hochbahn ergibt sich mit dem Radius der Lauffläche von $r_L=17mm$ und 200 Schritten pro Umdrehung eine maximale Geschwindigkeit von

\begin{equation}
	v(1050Hz) = \frac{2\pi \cdot f \cdot r_L}{200} \\
	= \frac{2\pi \cdot 1050 \cdot 17 \cdot 10^{-3}}{200} \\
	\approx 0,56 ms^{-1}.
\end{equation}

\subsection{Die Funktion \texttt{run}}
\label{sec:run}	

Der Motor wird außerhalb der Library mit der Funktion \texttt{run(int targetSpeed, int targetAcc)} gesteuert. Mithilfe der Parameters \textit{targetSpeed} und \textit{targetAcc} können die gewünschte Geschwindigkeit sowie Beschleunigung in \% definiert werden. Anhand des Vorzeichens wird mit der Funktion \texttt{setDir(targetSpeed)} die Drehrichtung eingestellt. Anschließend werden die Parameter \textit{targetAcc} sowie der Betrag von \textit{targetSpeed} in definierte Wertebereich transfomiert und in die globalen Klassenvariabeln \textit{targetRegVal} und \textit{acc} geschrieben. 
Die beiden Variabeln werden von der \acrshort{isr} verwendet. 

\subsection{Implementierung der \acrshort{isr}}
\label{sec:isr}	
Bei Aufruf der \acrshort{isr} \texttt{TIMER1\_COMPA\_vect} wird die klasseninterne Funktion \texttt{isr()} aufgerufen. Diese erzeugt das \acrshort{pwm}-Signal durch Umschalten des \textit{clk}-Ausgangs. 
Im nächsten Schritt wird der aktuelle Wert von \textit{0CR1A} mit dem von angestrebten Registerwert \textit{targetRegVal} verglichen. Je nach Ergebnis wird durch inkrementieren bzw. dekrementieren von \textit{0CR1A} der Motor beschleunigt oder verlangsamt. Die Häufigkeit der Veränderung des Zählwertes entspricht dem Wert der Beschleunigung und wird durch die Variable \textit{acc} bestimmt. 
Im letzten Schritt wird das Erreichen des gewünschten Registerwertes geprüft. Diese Information wird für die Abbremsmodi benötigt. Die Implementierung der \acrshort{isr} ist in \autoref{code:isr} dargestellt. 

\begin{lstlisting}[language=c, style=dhpaperdefault]
void Stepper::isr() {
	digitalWrite(CLK, !(digitalRead(CLK))); //togglen des CLK-Pins
	count++;
	
	//acelerate
	if (OCR1A > targetRegVal && count >= acc) {
		cli();
		OCR1A = OCR1A - 10;
		sei();
		count = 0;
	}

	//decelerate
	if (OCR1A < targetRegVal && count >= acc) {
		cli();
		OCR1A = OCR1A + 10;
		sei();
		count = 0;
	}
	
	//check target achievement (+offstet)
	if (abs(OCR1A - targetRegVal) <= 10) {
		accDone = true;
		OCR1A = targetRegVal;
}

\end{lstlisting}
\captionof{lstlisting}{\label{code:isr} Implementierung der ISR \textit{TIMER1\_COMPA\_vect}}


\subsection{Vorkonfiguration verschiedener Anhalteszenarien}
\label{sec:stopMode}
Mithilfe der Funktion \texttt{stopMode(int n)} können von außerhalb verschiedene Anhalteszenarien ausgeführt werden. Zusätzlich kann der Motor aktiviert und deaktiviert werden. In \autoref{tbl:stopMode} sind die ausführbaren Szenarien aufgeführt. 

\begin{table}[h]
	\begin{center}
		\begin{tabular}[h]{l|l|l}
			\textbf{Input} & \textbf{Bezeichnung} & \textbf{Fahrverhalten} \\
			\hline
			0 & Aktivieren des Motors & \\
			\hline
			1 & Nothalt & speed: 0\%, acc:100\%; Deaktivieren des Motors\\
			\hline
			2 & Normaler Halt &\parbox{8cm}{speed: 0\%, acc:50\%; $\frac{1}{2}$-Schritt; $\frac{1}{4}$-Schritt; \\Deaktivieren des Motors} \\
			\hline
			3 & Einfahrt in Ladestation & speed: 0\%, acc:50\%; $\frac{1}{2}$-Schritt; $\frac{1}{4}$-Schritt\\
			\hline
			4 & Deaktivieren des Motors & \\
		
		\end{tabular}
	\end{center}
	\caption{Übersicht über vorkonfigurierte Anhalteszenarien in der Funktion \texttt{stopMode(n)} mit darauffolgendem Fahrverhalten}
	\label{tbl:stopMode}
\end{table}

Ein Nothalt soll bspw. ausgelöst werden, wenn das Schutzfeld eines Ultraschallsensor verletzt wurde. In diesem Fall steht ein sanftes Abbremsen nicht im Vordergrund und der Motor wird mit einer Bremsverzögerung von 100\% zum Stillstand gebracht. Abschließend wird das Signal \textit{en} deaktiviert, wodurch der Motor nicht mehr bestrom wird. Im Vergleich dazu wird die Hochbahn bei einem normalen Halt mit einer Bremsverzögerung von 50\% auf die Taktfrequenz, die 0\% entspricht, verlangsamt. Diese Frequenz von $182 Hz$ entspricht einer Winkelgeschwindigkeit des Motors von 

\begin{align}
	\omega = \frac{182}{2\pi \cdot 200 \cdot s}  \approx 0,16 s^{-1}.
\end{align}

Da das Deaktivieren des Motors aus dieser Geschwindigkeit zu abrupt wäre, werden bei der Minimalfrequenz die Schrittmodi gewechselt. Dazu wechselt die Library sobald  das Flag \texttt{accDone} von der \acrshort{isr} gesetzt wurde, in den Halbschrittmodus. Nach einer Wartezeit von einer Sekunde wird der Viertelschrittmodus aktiviert und nach einer weiteren Sekunde der Motor abgeschaltet. Bei Einfahrt in die Ladestation wird der Motor zunächst in gleicher Weise verlangsamt. Im Vergleich zum normalen Halt wird der Motor am Ende nicht automatisch deaktiviert. Dafür kann von außen bei Erreichen des letzten \acrshort{reed}-Kontaktes der Motor gezielt abgeschaltet werden. 

\section{Getriebekonstruktion}
\label{sec:getriebekonstruktion}
Wie im Konzeptionierungsteil \ref{sec:getriebekonstruktion} beschrieben, soll für die Kraftübertragung des Motors auf die Schiene ein Riemengetriebe verwendet werden. In diesem Kapitel wird die Konstruktion des Getriebes beschrieben. In \autoref{pic:getriebe} ist eine Übersicht des Getriebes dargestellt. Auf die Bauteile wird nachfolgend genauer eingegangen. 

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=12cm]{getriebe.pdf}
		\caption{Gerenderte Konstruktionsansicht der Getriebekonstruktion}
		\label{pic:getriebe}
	\end{center}
\end{figure} 



\textbf{Das Laufrad}\\
Beim Laufrad beträgt der Durchmesser der Lauffläche $d=34mm$ bei einer Breite $b=5mm$. Für die Führung auf der Schiene sorgen seitliche Ränder. Diese besitzen eine Breite $b_R=2mm$ sowie einen Durchmesser $d=40mm$. Die Laufräder werden mit einem Rillenkugellager 6000 Welle gelagert. Das Lager wird mit Übermaßpassung verbaut. Das Laufrad ist in \autoref{pic:laufrad}dargestellt. \\

\begin{figure}[h]
	\centering
	\includegraphics[width=3cm]{laufrad.png}
	\caption{Konstruktionsansicht des Laufrades}
	\label{pic:laufrad}
\end{figure}
\newpage

\textbf{Die Riemenräder}\\   
Das Riemengetriebe besteht aus einem treibenden und getriebenen Riemenrad. Zunächst soll das Zahnprofil der beiden Riemenräder ausgelegt werden. Dafür ist die Grundlage der Zahnflachriemen mit einem äußeren Umfang von $U = 206mm$ und einer Riemenbreite von $b=9,5mm$. Die Zähnezahl des Riemens beträgt $z_R=75$. Folglich ist das Modul $m \approx 5$. \\

 Für das Zahnprofil muss ebenfalls das Modul $m=5$ verwendet werden. Die Zähnezahl wird auf $z=22$ festgelegt. Dadurch ergibt sich für den Kopfkreisdurchmesser $d_Z$ des Profils: 
 
 \begin{align}
 	d_Z =  \frac{m \cdot z}{\pi} = \frac{5 \cdot 22}{\pi} \approx 35,01
 \end{align}


Entsprechend der Abmessungen des Riemens wurde der Durchmesser der Zahnflanken auf 2mm festgelegt.  Das treibende Riemenrad (Ritzel) ist in \autoref{pic:ritzel} dargestellt. Es wird auf die Nabe des Motors gesteckt. Durch die Phase auf der Motorwelle geschieht die Übertragung des Drehmoments formschlüssig.  Das getriebene Riemenrad zeigt \autoref{pic:riemenlaufrad} und ist beidseitig gelagert. Dafür wird ebenfalls das Kugellager 6000 mit Übermaßpassung verbaut.  
 

\begin{figure}[h]
	\centering
	\begin{minipage}[t]{0.45\linewidth}
		\centering
		\includegraphics[width=4cm]{ritzel.png}
		\caption{Konstruktion des treibenden Riemenrades (Ritzel)}
		\label{pic:ritzel}
	\end{minipage}
	\hfil	
	\begin{minipage}[t]{0.45\linewidth}
		\centering
		\includegraphics[width=4cm]{riemenlaufrad.png}
		\caption{Konstruktion des getriebenen Riemenrades mit Laufrad}
		\label{pic:riemenlaufrad}
	\end{minipage}	
\end{figure}



\newpage


\textbf{Implementierung des Getriebes}\\
Der äußere Umfang des Riemens beträgt $U = 330mm$. Für die Berechnung des erforderlichen Abstandes $\Delta$ der beiden Wellen zueinander gilt:

\begin{align}
	U = 2 (r \cdot \pi+ \Delta) 
\end{align}

Und damit: 
\begin{align}	
	\Delta = \frac{U - 2r \cdot \pi}{2} = \frac{330mm - 35,01 \cdot \pi}{2} \approx 110mm 
\end{align}

Um den Wellenabstand zu erreichen, wird die Motoraufhängung nach unten entsprechend versetzt. Zusätzlich soll sich die Aufhängung nach der Montage in Y-Richtung justieren lassen. Dadurch kann der Riemen nach dem Einbau auf Spannung gebracht werden. Die Motoraufhängung ist in \autoref{pic:motoraufhaengung} dargestellt. 


\begin{figure}[h]
	\centering
	\includegraphics[width=5cm]{motoraufhaengung.png}
	\caption{Konstruktionsansicht der verschiebbaren Motoraufhängung}
	\label{pic:motoraufhaengung}
\end{figure}

Die Wellen werden axial beansprucht. Damit die Befestigung der Welle die axialen Kräfte aufnehmen kann, wird zusätzlich ein Rundmaterial an die Seitenteile montiert. 
\newpage

\chapter{Fertigung der Platine (INF)}
\label{sec:ecard}
\section{Schaltplan}
\label{sec:eCardPlan}
\autoref{pic:schaltplan} zeigt den gesamten Schaltplan für die Platine. Zu sehen sind ESP32, zwei Arduini, sowie Steppertreiber, ein \textcolor{red}{Relais} und diverse \textcolor{magenta}{Schraubklemmen} um beispielsweise die beiden \textcolor{orange}{Ultraschallsensoren} anzuschließen. Die \textcolor{blue}{Kommunikation zwischen Arduino und ESP} ist in \autoref{sec:uartecard} aufgeführt. Unter \autoref{sec:mosfetmess} ist die \textcolor{green}{Mosfetschaltung zur Spannungsmessung} erklärt. All diese Komponenten sind farblich im Schaltplan markiert. In \autoref{sec:konzeptEnergieversorgung} wurde das Energieversorgungskonzept erklärt, welches ebenfalls auf der Platine vorhanden sein muss.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=13.3cm]{schaltplan.jpg}
		\caption{\label{pic:schaltplan} Schaltplan der Platine}
	\end{center}
\end{figure}



\section{PCB-Design}
Der fertige Schaltplan aus \autoref{sec:eCardPlan} ist nun in ein fräsbereites Platinen Design umzuwandeln. Um den Fräsaufwand so gering wie möglich zu halten, werden alle elektronischen Verbindungen auf einer Seite platziert. Daraus folgt, dass es zu keinen Überlappungen von Verbindungen geben darf, da sonst der Stromfluss nicht mehr physisch getrennt wäre. Um den Verbindungsaufwand zu verringern, wurde \gls{gnd} auf die Kupferschicht gelegt. Da alle Komponenten den gleichen $-Pol$ haben, müssen sie an der entsprechenden Stelle lediglich an die Schicht gebunden werden, welche somit eine \gls{gnd}-Leitung ersetzt.
\vspace{0.5cm}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width = 12cm]{pcbDesign.png}
		\caption{\label{pic:pcbDesign} PCB-Design der Platine}
	\end{center}
\end{figure}

\autoref{pic:pcbDesign} zeigt den PCB-Entwurf für die Hauptplatine. Zu erkennen sind alle zuvor erwähnten Komponenten. Ebenfalls ersichtlich ist (weiß markiert) die 5V Versorgungsleitung. An die unten rechts platzierte Schraubklemme wird der StepUp Wandler für 10V angeschlossen. Dabei ist zu erkennen, dass diese Leitungen besonders dick (2mm) sind. Es handelt sich um die Versorgungsleitung für alle Komponenten, wodurch hier der meiste Strom fließt. Die Dicke verhindert eine Hitzeüberlastung der Leitung. Datensignale sind mit 0.3mm am dünnsten.
Ebenfalls ersichtlich wird, dass das Relais die Stromleitung der Batterie bereits vor dem Step-Up Wandler trennt. Der Grund dafür ist, dass im ausgeschaltenen Zustand kein Strom aus den Batterien fließen soll, was bei angeschlossenem Wandler der Fall wäre. 

\section{Fertigung}
Gefräst wurde die Platine in der Ausbildungsabteilung der SICK AG. Die bereits mit smd-Teilen bestückte Platine ist in \autoref{pic:ecardCopper} zu sehen. 

\begin{figure}[h]
	\begin{center}
		\includegraphics[width = 10cm]{eCardCopper.jpg}
		\caption{\label{pic:ecardCopper}Mit SMD-Teilen bestückte Platine}
	\end{center}
\end{figure}

Nach Verlöten der übrigen Komponenten und Anschluss von Step-Up-Wandler und Batterien konnte die Spannungsversorgung erfolgreich getestet werden. Dass die LEDs der Arduini leuchten und nirgends Überhitzung zu spüren ist zeigt, dass kein Kurzschluss herrscht. Mit dem Multimeter konnten zudem alle Spannungen überprüft werden. In \autoref{pic:ecardLights} ist die fertig bestückte Platine im aktivierten Zustand gezeigt. Die vier Löcher dienen später zur Befestigung in der Elektronikbox.


\begin{figure}
	\begin{center}
		\includegraphics[width=10cm]{ecardLight.jpg}
		\caption{\label{pic:ecardLights}Fertig bestückte Platine}
	\end{center}
\end{figure}

\chapter{Implementierung der Zustandsautomaten (INF)}
\label{sec:states}
Im folgenden wird die zuvor unter \autoref{sec:stateESP} konzeptionierte Logik des Zustandsautomaten des ESP32 implementiert.
C++ ist die hierbei verwendete Programmiersprache. Die Idee ist eine State Maschine, die zu jeder zeit einen aktuellen State (\texttt{currentState}) hat, welcher sich in Abhängigkeit von der Eingabe verändert. Beispielsweise soll die Maschine von \texttt{IDLE} nach \texttt{START} wechseln, sofern ein valider Fahrbefehl vom Server erhalten wurde.

\section{Die State Klassen}
Um den Validierungsaufwand innerhalb der Zustandsmaschine zu verringern, d.h. die Maschine muss nicht schauen, was für ein State \texttt{currentState} ist, erben alle Zustände von einer State-Klasse. Somit muss die Maschine später nur wissen, dass sie einen State hat und nicht welchen.
\autoref{code:state.h} zeigt die Header-Datei dieser State-Klasse.
\newpage
\begin{lstlisting}[language=c, style=dhpaperdefault]
	class State{
		public:
			int driveToPosition;
			String errorMsg;

			virtual int handle(byte);
			virtual int handle(String);
			virtual int handleWithoutParam();
			
			virtual void handle();
	};
\end{lstlisting}
\captionof{lstlisting}{\label{code:state.h} State-Klasse}

Die beiden Klassenvariablen \texttt{driveToPosition} und \texttt{errorMsg} werden verwendet, um State-übergreifende Parameter zu übergeben. Beispielsweise legt ein \texttt{Position-State} als \texttt{errorMsg} den String ''\textit{received invalid position}'' und übergibt diesen an Error-State, welcher die Nachricht an den Server schickt.
Die \texttt{handle}-Methoden geben jeweils ein \texttt{int} zurück, welches signalisiert in welchen Zustandn zu wechseln ist.
Im Folgendem wird die Implementierung der \texttt{handle}-Methoden am Beispiel des Idle-States erklärt:

\subsubsection{Die Idle State Klasse}
\label{sec:IdleState}
Der Zustandsautomat der Hauptsteuerung ist in \autoref{pic:statemaschineARD} zu sehen.
Idle-State hat dabei drei Aufgaben:
\begin{center}
	\begin{itemize}
		\item Batteriezellenzustände überprüfen und an den Esp schicken,
		\item das Zurückfahren zur Ladestation initialisieren falls nötig (Batterie leer)
		\item und das Warten auf eine Positionsanfrage seitens des ESPs.
	\end{itemize}
\end{center}
 Durch diese Aufgaben ergeben sich drei mögliche Zustandswechsel:
 \begin{center}
	\begin{itemize}
		\item \textit{Position State}, sobald eine Positionsanfrage erhalten wurde,
		\item \textit{Charge State}, wenn die BAtterie leer ist
		\item und \textit{Idle-State} nach Messen und verschicken der Batteriezustände.
	\end{itemize}
\end{center}
Hierbei ist zu bemerken, dass der Übergang $Idle State \Rightarrow  Idle State$ ebenfalls als Zustadswechsel angesehen wird.
Abhängig davon ob empfangene bytes im seriellen Puffer liegen oder nicht (d.h. es wurde eine Nachricht empfangen oder nicht), wird die jeweilige \texttt{handle} - Methode mit oder ohne Parameter aufgerufen. Der Parameter ist die empfangene Nachricht als byte.
Gibt es keine Empfangene Nachricht, führt Idle-State die Aufgabe \textit{Batterie messen} durch. Die Implementierung ist in \autoref{code:IdleState:handleWithoutParam} gezeigt.
\begin{lstlisting}[language=c, style=dhpaperdefault]
	int sIdle::handleWithoutParam() {
		float cell1 = batteryMeasure->getCellOneInPercent();
		float cell2 = batteryMeasure->getCellTwoInPercent();

		if (cell1 < 10.0 | cell2 < 10.0) {
			return CHARGE_STATE;
		}
		else {
			sIdle::sendBattery(cell1, cell2);
			return IDLE_STATE;
		}
		return ERROR_STATE;
	}
\end{lstlisting}
\captionof{lstlisting}{\label{code:IdleState:handleWithoutParam}Batteriemessung der Idle-State Klasse}
	\vspace{0.5cm}
\texttt{batteryMeasure} aus \autoref{code:IdleState:handleWithoutParam} ist ein Pointer auf eine Instanz der Klasse Battery Master. DIese Klasse bietet verschiedene Methoden, um den Abtteriezustand in verschiedenen Formaten zu erhalten. 
Die Methoden \texttt{getCellOneInPercent} und \texttt{getCellTwoInPercent} geben jeweils den Batteriezustand der Zelle in Prozent zurück. Liegen beide unter dem Schwellwert von 10\%, wird \texttt{CHARGE\_STATE} zurückgegeben, wodurch die Statemaschine daraufhin in den Zustand wechselt, welcher die Bahn zur Ladestation zurückfährt.
Ansonsten wird der Batteriezustand an den Arduino geschickt, und die Maschine wechselt wieder zu \texttt{IDLE}.
Wird eine Nachricht vom ESP empfangen, wird folgende Methode im Idle-Zustand aufgerufen: 
\vspace{0.5cm}
\begin{lstlisting}[language=c, style=dhpaperdefault]
	int sIdle::handle(byte espMsg) {
		if (messageHandler->getHeader(espMsg) == HEADER_ASK) {
		  return POSITION_STATE;
		}
		return ERROR_STATE;
	  }
\end{lstlisting}
\captionof{lstlisting}{\label{code:IdleState:handleByte}Nachrichtenvalidierung innerhalb der Idle-State KLasse}
\vspace{0.5cm}

\texttt{messageHandler} aus \autoref{code:IdleState:handleByte} ist ein Pointer auf eine Instanz der Klasse Decoder. Diese Klasse bietet mehrere Methoden, um Header, Body und Tail einer Nachricht einzeln als \texttt{int} zu erhalten um die Evaluation von Nachrichten zu vereinfachen.
Die Methode aus \autoref{code:IdleState:handleByte} überprüft, ob es sich bei der NAchricht um eine Positionsanfrage handelt. Ist dies der Fall, wechselt die Maschine den Zustand zu \texttt{POSITION\_STATE}, andernfalls zu \texttt{ERROR}, da diese handle-Methode nur mit Positionsanfragen aufgerufen werden darf.
Die anderen States implementieren auf ähnliche Weise die handle-Methode mit und ohne Parameter. Sie führen die Aufgaben des States durch und geben als \texttt{int} den neuen State zurück. 

\section{State-Machine}
Die State-Machine ist ein Klasse, dessen Objekt alle Zustandsübergänge verwaltet. Sie hat Zugriff auf emfangene Nachrichten und ruft, jenachdem ob es eine neue Nachricht gibt, die Methode \texttt{handle} des aktuellen Zustands mit oder ohne byte-Parameter auf. Abhängig vom Rückgabewert der Funktion wird der aktuelle State gelöscht, und der korrekte neue State initialisiert. \autoref{code:machineHandle} zeigt einen Ausschnitt einer solchen Methode der Zustandsmaschine auf der Hauptsteuerung. Zum Vergleich ist der Zustandsautomat aus \autoref{pic:statemaschineARD} einzusehen.
\vspace{0.5cm}
\begin{lstlisting}[language=c, style=dhpaperdefault]
void StateMaschine::StateHandle() { 
	switch (this->currentState->handleWithoutParam()) {
		case IDLE_STATE:
		delete (this->currentState);
		this->currentState = new sIdle;
		break;
		case POSITION_STATE:
		delete(this->currentState);
		this->currentState = new sError();
		break;
		//other states
		case ERROR_STATE:
		delete(this->currentState);
		this->currentState = new sError();
		this->currentState->handle();
		delete(this->currentState);
		this->currentState = new sIdle();
		break;
	}
}
\end{lstlisting}
\captionof{lstlisting}{\label{code:machineHandle}Handle-Methode zum Zustandsübergang ohne empfangene Nachricht}

Das Switch-Case dient dazu den richtigen State zu Initialisieren. In diesem Beispiel würde im Fall \texttt{IDLE\_STATE} ein neuer Idle-State initialisiert. Im Falle \texttt{POSITION\_STATE} erfolgt ein Wechsel zu Error-State, da es keinen Fall geben sollte indem ohne \texttt{byte}-Parameter (Positionsabfrage) zu \texttt{POSITOIN\_STATE} gewechselt werden kann. Gibt ein Zustand selbst, aufgrund von Fehlern bei der Ausführung, \texttt{ERROR\_STATE} zurück, wird ein Error-State initialisiert und ausgeführt. Die Ausführung validiert, im Falle der Hauptsteuerung, wie gravierend, bzw. gefährlich der Fehler ist und führt falls nötig einen Nothalt aus. In diesem Fall müsste die Bahn in Anfangsposition neugestartet werden. Ist kein Nothalt nötig, wird ein Fehler mit einer Status-LED signalisiert, und die Maschine wechselt wieder zu Idle. 
\\ Die weiteren States und Übergangsfunktionen werden auf gleiche Weise mit ihren jeweiligen Anpassungen (z.B. IdleState der Hauptsteuerung misst die Batterie wenn keine Nachricht emfangen wurde) implementiert. Somit ergeben sich folgende Klassen für die Zustandsmaschinen von Arduino und ESP:

\begin{lstlisting}[language=c, style=dhpaperdefault]
//State-Machine Arduino
class StateMachine{
	private:
		State *currentState;
	public:
		StateMachine();
		~StateMachine();
		void handle();
		void StateHandle();
		void StateHandle(byte);
		void clearSerialBuffer();
};
//State-Machine ESP
class StateMachine{
	private:
		State *currentState;
	public:
		StateMachine();
		~StateMachine();
		void handle();
		void StateHandle();
		void StateHandle(byte);
		void StateHandle(String);
		void clearSerialBuffer();
};
\end{lstlisting}
\captionof{lstlisting}{\label{code:stateMachines} State-Maschinen von ESP und Arduino}

In \autoref{code:stateMachines} sind die KLassendefinitionen der Zustandsmaschinen von ESP und Arduino gezeigt. Die Klasse auf dem ESP hat im Vergleich zur Zustandsmaschine auf dem Arduino eine weitere Überladung der Methode \texttt{StateHandle} mit einem \texttt{String} als Übergabeparameter. Diese dient dazu, Nachrichten die vom Server mit \acrshort{mqtt} übertragen wurden evaluieren zu lassen. die Methode \texttt{handle} wird aus der \texttt{main} aufgerufen und verwaltet Nachrichten. D.h. sie ruft je nach Nachrichteneingang die Methode \texttt{StateHandle} ohne oder mit entsprechendem Parametern auf. 

\chapter{Implementierung der Fahrfunktion (INF)}
\label{sec:driveFunc}
Zur Implementierung der Fahrfunktion wird eine Klasse namens Drivehandler erstellt. Wie bereits in \autoref{sec:konFahr} erwähnt, wird eine Fahrt mithilfe von Maximalgeschwindigkeiten auf mehreren Abschnitten realisiert. Dazu besitzt die Klasse zwei Arrays: 

\begin{center}
	\begin{itemize}
		\item \texttt{int sectionSpeeds[8] = \{0,30,30,40,80,100,90,0\};}
		\item \texttt{int driveSpeeds[8] = \{0,0,0,0,0,0,0,0\};}
	\end{itemize}
\end{center}

\texttt{sectionSpeeds} ist ein Array vom Typ \texttt{int} und dient dazu, jedem Abschnitt einen vordefinierten Wert für die Maximalgeschwindigkeit zu geben. \texttt{driveSpeeds} ist ein Array was für jede individuelle Fahrt angepasst wird. Über eine Variable \texttt{driveArrayMaxIndex} kann die Anzahl der Abschnitte reduziert werden für kürzere Fahrten. \\
Die Klasse besitzt zudem die beiden Methoden \texttt{drive()} und \texttt{setDriveSpeeds()}. Letztere füttert das Array \texttt{driveSpeeds} mit den richtigen Werten welche sich aus den vier Fahrtregeln aus \autoref{sec:rules} ergeben. \texttt{drive()} soll im Anschluss daran die Fahrt durchführen. \\
Im Konstruktor werden mehrere Werte gesetzt, welche zur Vorbereitung für das Setzen der richtigen Fahrtwerte dienen. Er wird mit zwei Werten aufgerufen: \texttt{from} und \texttt{to}. Hierbei handelt es sich um die aktuelle Position der Bahn, sowie die Zielposition. Anhand dieser Informationen können folgende Werte leicht ermittelt werden:

\begin{itemize}
	\item Fahrtrichtung der Hochbahn
	\item und \texttt{driveArrayMaxIndex}.
\end{itemize}

Nun besitzt die Klasse alle benötigten Informationen um eine Fahrt zu bestimmen.

\section{Die richtigen Fahrtwerte setzten}

Die Reihenfolge der Regelanwendungen ist ausschlaggebend für die jeweilige Priorität. Angenommen an Index 0 ist die Zahl 10 gespeichert. Werden nun zwei Regeln die jeweils die Zahl an Index 0 verändern angewendet, hat die zuletzt ausgeführte Regel eine höhere Priorität, da sie den zuvor bearbeiteten Wert einfach überschreibt. \\
Da die vordefinierten Werte die niedrigste priorität haben, wird das Array zuerst mit den richtigen Maximalgeschwindigkeiten für die Fahrt beschrieben. 
\vspace{0.5cm}
\begin{lstlisting}[language=c, style=dhpaperdefault]
//prio 4
for (int i = 0; i <= driveArrayMaxIndex; i++) {
	if(isDrivingForward) {driveSpeeds[i] = sectionSpeeds[(from + i)]; }
	else {driveSpeeds[i] = sectionSpeeds[(from - i)]; }
}

\end{lstlisting}
\captionof{lstlisting}{\label{code:prio4} Setzen der Default - Maximalgeschwindigkeitswerte}
\vspace{0.5cm}
\autoref{code:prio4} zeigt, wie in Abhängigkeit von der Fahrtrichtung die einzelnen Werte mit vordefinierten Geschwindigkeiten gestezt werden. Dabei iteriert eine for-Schleife von Null bis zum Maximalindex, d.h. maximalindex entspricht der Fahrlänge. Da dass Array \texttt{driveSpeeds} immer die Werte in Fahrtrichtung angibt, müssen die Werte aus \texttt{sectionSpeeds} mit auf- oder absteigendem Index gelesen werden. \\
Bei den restlichen Regeln kann auf eine Abfrage der Fahrtrichtung verzichtet werden, da nun in jedem Fall Index 0 der erste Geschwindigkeitsabschnitt der Fahrt ist.
\vspace{0.5cm}
\begin{lstlisting}[language=c, style=dhpaperdefault]
//prio3
if (driveSpeeds[0] > driveSpeeds[1]) {
	driveSpeeds[0] = driveSpeeds[1];
}

//prio2
if(driveSpeeds[(driveArrayMaxIndex-1)] > 50){
	driveSpeeds[(driveArrayMaxIndex-1)] = 50;
}

//prio1
driveSpeeds[driveArrayMaxIndex] = 0; 
\end{lstlisting}
\captionof{lstlisting}{\label{code:prio312} Anwenden der restlichen Regeln}
\vspace{0.5cm}
Die zweite anzuwendende Regel sollte verhidnern dass die Bahn beim Anfahren unnötig hoch beschleunigt. Dazu wird, falls der Wert an Index 0 größer als jener an Index zwei ist, der Wert an Index 0 gleich dem Wert an Index zwei egsetzt. Im Anschluss daran wird die Geschwindigkeit im Vorletzten Abschnitt auf Maximal 50 gesetzt. Als letztes wird die Geschwindigkeit im letzten Abschnitt aus 0 gesetzt, damit die Hochbahn im gewünschten Abschnitt anhält. Das Anhalten an sich unterscheidet sich bei normalen Abschnitten im gegensatz zden beiden Endpunkten der Strecke. Dies wird allerdings von der Methode \texttt{drive()} übernommen, da die Logik dieser Funktion durch das simple Anhalten der Bahn erfüllt ist. Wie genau die Bahn anhält fällt nicht in den Aufgabenbereich des Setzens der Maximalwerte.

\section{Das eigentliche Fahren}
Sind die Werte für die Maximalgeschwindigkeit der einzelnen Abschnitte richtig gesetzt, kann nun eine Fahrt durchgeführt werden. Um den Motor anzusteuern, wird die unter \autoref{sec:motorsteuerung} entwickelte Library \texttt{HighTrainStepper} verwendet. Besser gesagt, sind die Methoden \texttt{linear} und \texttt{stopMode} zu verwenden. In Folgendem ist eine einfache Fahrt dargestellt, bei der das passieren eines Magneten simuliert wird. 

\vspace{0.5cm}
\begin{lstlisting}[language=c, style=dhpaperdefault]
if (this->isDrivingForward) {
for (int i = 0; i < this->driveArrayMaxIndex; i++) {
	this->stepper->linear(driveSpeeds[i]);
	delay(7000); //fake reed contact
}
}
else {
int s = 0;
for (int i = 0; i < this->driveArrayMaxIndex; i++) {
	s = driveSpeeds[i] * (-1);
	this->stepper->linear(s);
	delay(7000); //fake reed contact
}
}
\end{lstlisting}
\captionof{lstlisting}{\label{code:drive} Die Fahrfunktion}
\vspace{0.5cm}

In \autoref{code:drive} ist zu erkennen, wie der Pointer auf ein \texttt{HighTrainStepper} in Abhängigkeit von der Fahrtrichtung die Methode \texttt{linear} aufruft. Der Wert für die anzupeilende Geschwindigkeit wird dem Array \texttt{driveSpeeds} entnommen. Fährt die Bahn Rückwärts, wird der Wert invertiert, sodass sich der Motor entsprechend andersherum dreht. Die hier verwendete Methode \texttt{delay} simuliert das Passieren eines Magneten, indem sie das Programm für eine gewisse Zeit stoppt. Das Programm verhält sich also so, als würde alle sieben Sekunden ein Magnet passiert werden. Da die Methode \texttt{linear} innerhalb der \texttt{for}-Schleife aufgerufen wird, kann mit der Variable \texttt{i} jedesmal auf den richtigen Index des Arrays \texttt{driveSpeeds} zugegriffen werden. \\
Sind alle Abschnitte passiert, wird in Abhängigkeit davon ob der Zielabschnitt ein Endabschnitt (null oder sieben) ist, die Methode \texttt{stopMode} mit dem Parameter \texttt{2} oder \texttt{3} aufgerufen. DIeser Vorgang ist in \autoref{code:stop} zu sehen.

\vspace{0.5cm}
\begin{lstlisting}[language=c, style=dhpaperdefault]
if (this->to == 0 || this->to == 7) {
	this->stepper->stopMode(3);
	}
else {
	this->stepper->stopMode(2);
}
\end{lstlisting}
\captionof{lstlisting}{\label{code:stop} Anhalten im letzten Abschnitt}
\vspace{0.5cm}

\texttt{stopMode(3)} hält erst am Ende, also mit Erkennen des letzten Magneten an, während \texttt{stopMode(2)} die Bahn auf Geschwindigkeit 0 abbremst.

\chapter{Montage und finaler Stand (INF + MT)}
\label{sec:final}
Bevor die Endmontage angestoßen werden konnte, mussten die mechatronischen Komponenten mit dem softwareseitigen Part verknüpft werden. Als Schlüsselstelle stellte sich dabei die Fahrfunktion heraus. Diese diente letztlich auch als Test für die erfolgreiche Verknpüfung der beiden Bereiche. Dazu wurde die gesamte Software auf die Controller geladen und die Komponenten über die Platine verdrahtet. Der Server lief lokal über den Computer. Dabei konnten sowohl Smartphone als auch Hochbahn-Controller darauf zugreifen. Auf der Website wurde bereits der Akkustand angezeigt. Durch Senden von Fahrbefehlen wurden als Test Transportfahrten simuliert. Innerhalb dieser Tests wurden die Geschwindigkeitsprofile durch den Motor entsprechend der Regeln wie gewünscht ausgeführt. \\

Für die Endmontage wurden als weitere Komponenten eine Ladevorrichtung sowie eine Haltuerung für den Reed-Kontakt entwickelt. Die beiden Komponenten sind in \autoref{pic:ladeReedVorrichtung} dargestellt. Über die Ladevorrichtung können die Akkus der Hochbahn in der Ladestation geladen werden. Dafür sind auf der Ladevorrichtung zwei Schleifkonakte, die von Märklin für H0-Eisenbahnen verkauft werden, angebracht. \\ 
In der Halterung der Reed-Kontakte sind Aussparungen zum Einkleben des Kontaktes vorgesehen. Für die Anschlussdrähte sind weitere Aussparungen vorgesehen. Die Neodym-Magnete wurden ebenfalls während der Endmontage an den Schienen angebracht.\\

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=14cm]{ladevorrichtungReedHalter.pdf}
		\caption{CAD-Konstruktion der für die Endmontage entwickelten Komponenten \textit{Ladevorrichtung} und \textit{Reed-Kontakt Halter}}
		\label{pic:ladeReedVorrichtung}
	\end{center}
\end{figure}
\newpage



Der nach der Endmontage im Mechatroniklabor fertiggestelle Aufbau ist in \autoref{pic:hochbahnLab}
gezeigt. 
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=14cm]{hochbahnLab.pdf}
		\caption{Gartenhochbahn nach der Endmontage im Mechatronik-Labor}
		\label{pic:hochbahnLab}
	\end{center}
\end{figure}
\newpage


Die Gartenhochbahn im finalen Endzustand an der Schiene ist in \autoref{pic:final}
 dargestellt. Abschließend wurde eine finale Testfahrt in der vorgesehenen Umgebung durcheführt. An der Schiene wurden Neodym-Magneten für die Reed-Kontakte befestigt. Dieser wurde erfolgreich abgeschlossen.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=13cm]{final.jpg}
		\caption{\label{pic:final} Ergebnis der Studienarbeit}
	\end{center}
\end{figure}

%-------------------------FAZIT UND AUSBLICK-----------------


\chapter{Fazit und Ausblick (INF + MT)}
\label{sec:end}
Im ersten Teil der Studienarbeit standen Grundlagen, Anforderungen sowie Konzepte im Vordergrund. Diese Arbeit wurde nun mit der Implementierungsphase fortgeführt. Währenddessen musste flexibel auf notwendige Anpassungen reagiert werden und besonders auf die Funktion der Schnittstellen geachtet werden. Abschließend können  wir mit dieser Arbeit ein fertiges und voll funktionsfähiges Endprodukt vorstellen. \\

Mit diesemTeil folgen mit \autoref{sec:fazit} die persönlichen Fazits zur eigenen Disziplin sowie Zusammenarbeit und mit \autoref{sec:ausblick} ein Ausblick. 


\section{Persönliche Fazits}
\label{sec:fazit}

\subsection{Jan Bantle - Mechatronik}

Der mechatronische Arbeitsprozess umfasste die Grundlagenforschung, Systemanalyse, Konzeptionierung sowie die Implementierung. Während des Prozesses mussten Aufgaben aus den unterschiedlichsten Bereichen fachlich und zeitlich abgestimmt werden. Um die Wirkzusammenhänge zu erkennen, stellte  der Projektstrukturplan eine ideale Grundlage dar. Als Beispiel für die Wichtigkeit der Abstimmung seien die Arbeitsfelder Motor, Aktorik und Getriebe genannt. Es musste je nach Drehmoment des Motors  ein anderes Übersetzungsverhältnis beim Getriebe konzeptioniert, sowie eine größere Leistung durch die Akkus bereitgesttellt werden. Eine zeitliche Abstimmung musste vor allem dort stattfinden, wo die hardware-technischen Komponenten Voraussetzung die software-seitigen Themen der Informatik waren. Es stellt sich heraus, dass ein Zeitplan ebenso wichtig war wie die situationsbedingte Priorisierung der Arbeitspakete. Insgesamt konnte aus der Studienarbeit einiges an Arbeitsorganisation für das zukünftige Berufsleben erlangt werden. \\


Besonders positiv hervorzuheben ist der intensive Praxisbezug. Während die betreffenden Inhalte zuvor fast ausschließlich in der Theorie bekannt waren, kam bei diesem Projekt die Praxis von der CAD-Konstruktion bis zur Fertigung in der Werkstatt nicht zu kurz. Dabei war es interessant zu sehen, wie weit die theoretischen Konzepte von der praktischen Umsetzung auseinanderliegen können. Bspw. wurde mir durch diese Arbeit deutlich, wie entscheidend die Auswahl einer geeigneten Fertigungsmethode sowie eine fertigungsgerechte Konstruktion ist.  \\

Die größte Herausforderung stellte für mich die Schnittstellenkommunikation dar. Die Forderung nach einer durchgängige Kommunikation hatte zur Folge, dass statt einer herkömmlichen Library zur Motorsteuerung eine eigene Library mit Interrupts geschrieben werden musste. Um die Implemetierung nebst anderer Librarys auf dem Arduino Nano zu bewerkstelligen, musste dabei objektorientiert vorgegangen werden. Abschließend lässt sich sagen, dass durch das Projekt Studieninahlte sowie Arbeitsorganisation in einer prakischen Art erlernt wurden.

\subsubsection{Zusammenarbeit im Hinblick auf die interdisziplinäre Arbeitsform}
Besonders bei den Schnittstellen stellte sich heraus, wie wichtig die Absprache zwischen uns war. Dass die Bewerkstelligung letztlich so gut funktioniert hat, ist ein Beispiel dafür, dass die Zusammenarbeit stets gut funktioniert hat. Generell eignet sich für eine interdisziplinare Studienarbeit hervorragend dafür, die Wichtigkeit der Absprache zweier Fachbereiche zu erkennen. Das Projekt könnten ebenso eine alltägliche Situation aus dem Arbeitsleben mit Experten aus verschiednenen Fachbereichen darstellen. Durch diese Art der Studienarbeit konnten Moritz und ich jeweils in unserem Expertengebieten unser Bestes geben während wir uns auch in die jeweiligen anderen Bereichen hineinwagten. Bspw. führte Moritz das Platinendesign durch während ich meine Library objektorientiert implementiert habe. Dies war nur dadurch möglich, dass jeder den anderen mit seinem Expertenwissen zur Seite gestanden ist. Mir hat die Zusammenarbeit stets viel Freude bereitet und ich hatte die Chance, durch den interdisziplinären Anteil viele Einblicke in informationstechnischen Themen zu bekommen. 


\subsection{Moritz Knapp}
Da ich solche Art von Projekten auch schon vorher gerne umgesetzt habe, bereitete mir auch die eigenständige Arbeit sehr viel Freude. Ich habe vorher noch nie ein verteiltes System konzeptioniert und implementiert, daher konnte ich hierbei sehr viel lernen. Ich konnte mein Wissen und meine Erfahrung in objektorientierten Programmieren und auch Netztechnik vertiefen und erweitern. Die Programmierung von Frontend / Backend des Servers und verteiltes System mit Mikrocontrollern auf der Hochbahn ermöglichte die Anwendung von viel Wissen aus den Theorieinhalten über Webengineering und Embedded-Programming. Negativ anzumerken ist an dieser Stelle mein Zeitmanagement. Ich habe mir selbst zu wenig Deadlines gesetzt, sodass sich manche Dinge, wie beispielsweise die Implementierung der Zustandsautomaten, länger hingezogen haben. Hätte ich mir dabei strengere Richtlinien gegeben, hätte ich mehr Zeit zur Verbesserung des Systems gehabt. Beispielsweise das Protokoll zwischen den Controllern hätte ausgebaut werden können, um noch mehr Informationen auch vom Arduino an den Server zu übertragen. 
\subsubsection{Zusammenarbeit im Hinblick auf die interdisziplinäre Arbeitsform}
Ich persönlich kann auf die Art der Zusammenarbeit bei diesem Projekt nur positiv zurückblicken. Es hat sich schnell herauskristalliert, dass Jan den mechanischen Aufbau plant, während Ich die Software konzeptioniere. Aus den dabei entstandenen Anforderungen konnte die Planung der Platine gemeinsam gut umgesetzt werden. Für mich war ebenfalls der Einblick in mechanische Fertigungsverfahren sehr lehrreich. Ich bezeichne mich gerne als Hobbybastler. Dementsprechend hat es unglaublich viel Spass gemacht, von Jan professionelle mechanische Arbeiten wie beispielsweise das Drehen der Antriebswelle beigebracht zu bekommen. Gerade als Informatiker ist ein Einblick in praktische Arbeiten wie Mechanik eine spannende Abwechslung. Ich hoffe, ich konnte Jan bei der Programmierung der Schrittmotorsteuerung unterstützen und ihm dabei ein bisschen Informatiker-Denken mitgeben konnte. Ich möchte hierbei auch positiv hervorheben, wie gut die getrennte Programmierung des Arduinos funktioniert hat. Wir haben uns abgesprochen, was genau die Funktionen können sollen, und ich konnte sie später genau so in meinem Code einbauen, wie wir das gedacht haben. 


\section{Ausblick}
\label{sec:ausblick}

Genrerell wurde die Software in diesem Projekt so konzeptioniert, dass sie leicht erweiterbar ist. Anstelle eines lokal gehosten Servers auf dem ESP32, welcher die gleichen Anforderungen des Endergebnisses erfüllen könnte, wurde ein richtiger Server auf Basis von \acrshort{mvc} erstellt. Dadurch ist eine Grundlage gegeben, auf der ein Bestellsystem gut aufgebaut werden kann. Außerdem sind die einzelnen Seiten leicht erweiterbar, sodass mehr Informationen der Hochbahn angezeigt werden können. Ein Beispiel dazu wäre eine dynamische Anzeige zur aktuellen Position der Hochbahn als eine kleine Animation. \\
Das verteilte System der Hochbahn ist auch noch in vielerlei Hinsicht erweiterbar. Aktuell verwendet es nur ein Byte pro Nachricht die zu verschicken ist. Dadurch ist eine gute Grundlage des Informationsflusses gegeben, die allerdings mit mehreren Bytes pro Nachricht erweiterbar ist. Beispielsweise könnte so auch der Arduino eigene Fehlermeldungen an den ESP übermitteln, welcher diese dann dem Server sendet. Dadurch könnte dem Nutzer die Fehlerdiagnose enorm erleichtert werden. \\
Eine erweiterte Kommunikation über \acrshort{mqtt} ist ebenfalls möglich. Dadurch könnten individuellere Fahrten durchgeführt werden. Wäre der Server um eine Benutzerdatenbank erweitert, könnte beispielsweise jeder Nutzer eigene Fahrprogramme mit eigenen Höchstgeschwindigkeiten der einzelnen Abschnitte erstellen. Diese müssten dann ebenfalls durch eine erweiterte Kommunikation vom ESP an den Arduino übermittelt werden. Ein weiteres Konzept der individuellen Fahrten verschiedener Nutzer wäre die Möglichkeit, eine Farbe zu wählen, welche von RGB-LEDs auf der Hochbahn angezeigt wird. Die RGB-Codes des Nutzers würden dann ebenfalls über \acrshort{mqtt} übermittelt. Dazu müsste die Hochbahn allerdings auch über entsprechende LEDs wie beispielsweise Neopixel-Ringe verfügen. Diese könnten direkt an den ESP angeschlossen werden, sodass dieser die Farben anzeigt, während der Arduino die individuelle Fahrt steuert. \\
Viele der oben aufgeführten Ideen werden in zukünftigen Projekten zur Erweiterung mit hoher Wahrscheinlichkeit angegangen. Zu Beginn wäre hier aber die Kommunikation sowohl über \acrshort{mqtt} als auch über \acrshort{uart} zu erweitern, sodass komplexere Systeme darauf aufgebaut werden können.\\

Hinsichtlich des mechatronischen Teils könnte eine detailliertere Lageerfassung implementiert werden. Durch die Verwendung des Schrittmotors ist der Weg für die inkrementale Lageerfassung bereits geebnet. Diese Positionsvorhersagen könnte dann durch die bereits implementierten Erfassung per Reed-Kontakte als absolute Lageerfassung ergänzt werden. Des Weiteren wäre eine automatische Absenkung des Tabletts nach Ankunft am Abgabe- oder Aufnahmeort denkbar. Falls der Auslenkwinkel des Tabletts beim Beschleunigen oder Abbremsen in der Zukunft Probleme bereitet, wäre eine winkelabhängige Drehzahlregelung denkbar. Dadurch könnten die Geschwindigkeiten generell in Abhängigkeiten vom Transportgut gesetzt werden und würden sich daher situationsbedingt anpassen. 

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=\textwidth]{abschlussbild.jpg}
		\caption{Abschlussbild}
	\end{center}
\end{figure}


